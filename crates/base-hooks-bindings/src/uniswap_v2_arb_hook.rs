/**

Generated by the following Solidity interface...
```solidity
interface UniswapV2ArbHook {
    struct DEXConfig {
        address router;
        string name;
        bool enabled;
    }

    error ArbitrageFailed();
    error DEXNotSupported();
    error InsufficientProfit();
    error InvalidDEXConfig();
    error InvalidEventData();
    error OwnableInvalidOwner(address owner);
    error OwnableUnauthorizedAccount(address account);
    error ReentrancyGuardReentrantCall();
    error UnauthorizedCaller();

    event ArbitrageExecuted(address indexed primaryDEX, address indexed secondaryDEX, address indexed tokenIn, address tokenOut, uint256 amountIn, uint256 profit);
    event ArbitrageSkipped(address indexed pair, string reason);
    event DEXAdded(address indexed router, string name);
    event DEXRemoved(address indexed router);
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor();

    receive() external payable;

    function _executeArbitrageLogic(address pairAddress, uint256 amount0In, uint256 amount1In, uint256 amount0Out, uint256 amount1Out) external;
    function _getAmountOut(address router, address tokenIn, address tokenOut, uint256 amountIn) external view returns (uint256);
    function addDEX(address router, string memory name) external;
    function authorizedTokens(address) external view returns (bool);
    function dexConfigs(address) external view returns (address router, string memory name, bool enabled);
    function gasCostBuffer() external view returns (uint256);
    function getDEXInfo(address router) external view returns (DEXConfig memory);
    function getSupportedDEXCount() external view returns (uint256);
    function maxTradeSize() external view returns (uint256);
    function minProfitThreshold() external view returns (uint256);
    function onHook(address contractAddr, bytes32 topic0, bytes32 topic1, bytes32 topic2, bytes32 topic3, bytes memory eventData) external;
    function owner() external view returns (address);
    function pairRegistry(bytes32) external view returns (address);
    function pairToDEX(address) external view returns (address);
    function registerPair(address tokenA, address tokenB, address pairAddress, address dexRouter) external;
    function removeDEX(address router) external;
    function renounceOwnership() external;
    function sequencer() external view returns (address);
    function setAuthorizedToken(address token, bool authorized) external;
    function setGasCostBuffer(uint256 buffer) external;
    function setMaxTradeSize(uint256 size) external;
    function setMinProfitThreshold(uint256 threshold) external;
    function setSequencer(address _sequencer) external;
    function supportedDEXes(uint256) external view returns (address);
    function transferOwnership(address newOwner) external;
    function withdrawETH(uint256 amount) external;
    function withdrawToken(address token, uint256 amount) external;
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "constructor",
    "inputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "receive",
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "_executeArbitrageLogic",
    "inputs": [
      {
        "name": "pairAddress",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "amount0In",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "amount1In",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "amount0Out",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "amount1Out",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "_getAmountOut",
    "inputs": [
      {
        "name": "router",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "tokenIn",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "tokenOut",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "amountIn",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "addDEX",
    "inputs": [
      {
        "name": "router",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "name",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "authorizedTokens",
    "inputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "dexConfigs",
    "inputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "router",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "name",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "enabled",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "gasCostBuffer",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getDEXInfo",
    "inputs": [
      {
        "name": "router",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "tuple",
        "internalType": "struct UniswapV2ArbHook.DEXConfig",
        "components": [
          {
            "name": "router",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "name",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "enabled",
            "type": "bool",
            "internalType": "bool"
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getSupportedDEXCount",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "maxTradeSize",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "minProfitThreshold",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "onHook",
    "inputs": [
      {
        "name": "contractAddr",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "topic0",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "topic1",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "topic2",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "topic3",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "eventData",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "owner",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "pairRegistry",
    "inputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "pairToDEX",
    "inputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "registerPair",
    "inputs": [
      {
        "name": "tokenA",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "tokenB",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "pairAddress",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "dexRouter",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "removeDEX",
    "inputs": [
      {
        "name": "router",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "renounceOwnership",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "sequencer",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "setAuthorizedToken",
    "inputs": [
      {
        "name": "token",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "authorized",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setGasCostBuffer",
    "inputs": [
      {
        "name": "buffer",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setMaxTradeSize",
    "inputs": [
      {
        "name": "size",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setMinProfitThreshold",
    "inputs": [
      {
        "name": "threshold",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setSequencer",
    "inputs": [
      {
        "name": "_sequencer",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "supportedDEXes",
    "inputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "transferOwnership",
    "inputs": [
      {
        "name": "newOwner",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "withdrawETH",
    "inputs": [
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "withdrawToken",
    "inputs": [
      {
        "name": "token",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "event",
    "name": "ArbitrageExecuted",
    "inputs": [
      {
        "name": "primaryDEX",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "secondaryDEX",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "tokenIn",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "tokenOut",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "amountIn",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "profit",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "ArbitrageSkipped",
    "inputs": [
      {
        "name": "pair",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "reason",
        "type": "string",
        "indexed": false,
        "internalType": "string"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "DEXAdded",
    "inputs": [
      {
        "name": "router",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "name",
        "type": "string",
        "indexed": false,
        "internalType": "string"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "DEXRemoved",
    "inputs": [
      {
        "name": "router",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "OwnershipTransferred",
    "inputs": [
      {
        "name": "previousOwner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "newOwner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "error",
    "name": "ArbitrageFailed",
    "inputs": []
  },
  {
    "type": "error",
    "name": "DEXNotSupported",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InsufficientProfit",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidDEXConfig",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidEventData",
    "inputs": []
  },
  {
    "type": "error",
    "name": "OwnableInvalidOwner",
    "inputs": [
      {
        "name": "owner",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "OwnableUnauthorizedAccount",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "ReentrancyGuardReentrantCall",
    "inputs": []
  },
  {
    "type": "error",
    "name": "UnauthorizedCaller",
    "inputs": []
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod UniswapV2ArbHook {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x6080604052655af3107a4000600555678ac7230489e80000600655662386f26fc1000060075534801562000031575f80fd5b50335f73ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1603620000a6575f6040517f1e4fbdf70000000000000000000000000000000000000000000000000000000081526004016200009d9190620001c9565b60405180910390fd5b620000b781620000c560201b60201c565b5060018081905550620001e4565b5f805f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050815f806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508173ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a35050565b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f620001b18262000186565b9050919050565b620001c381620001a5565b82525050565b5f602082019050620001de5f830184620001b8565b92915050565b6136fb80620001f25f395ff3fe60806040526004361061019f575f3560e01c8063898622e8116100eb578063b663bce411610089578063dcbe43d911610063578063dcbe43d9146105b4578063e7c2269e146105dc578063f14210a61461061a578063f2fde38b14610642576101a6565b8063b663bce414610526578063c028646514610562578063d6b2ab241461058a576101a6565b80639bc7c586116100c55780639bc7c5861461044a5780639e281a9814610486578063ac3c34b8146104ae578063adb7092a146104ea576101a6565b8063898622e8146103ce5780638c8f3f82146103f85780638da5cb5b14610420576101a6565b80634b3f3378116101585780635c1bba38116101325780635c1bba381461033c578063715018a6146103665780637341ab8c1461037c57806382cc696d146103a6576101a6565b80634b3f3378146102b05780634caf81f5146102d857806353fc838b14610314576101a6565b8063095bf923146101aa57806310fa79e2146101d2578063161efb62146101fc5780632547fa3e146102385780633ea6f207146102605780633f8a346714610288576101a6565b366101a657005b5f80fd5b3480156101b5575f80fd5b506101d060048036038101906101cb91906123cf565b61066a565b005b3480156101dd575f80fd5b506101e6610b81565b6040516101f39190612455565b60405180910390f35b348015610207575f80fd5b50610222600480360381019061021d919061246e565b610b87565b60405161022f9190612599565b60405180910390f35b348015610243575f80fd5b5061025e6004803603810190610259919061246e565b610cdc565b005b34801561026b575f80fd5b506102866004803603810190610281919061264d565b610d27565b005b348015610293575f80fd5b506102ae60048036038101906102a991906126f7565b610e2e565b005b3480156102bb575f80fd5b506102d660048036038101906102d1919061275b565b610f14565b005b3480156102e3575f80fd5b506102fe60048036038101906102f9919061275b565b610f26565b60405161030b9190612795565b60405180910390f35b34801561031f575f80fd5b5061033a600480360381019061033591906127d8565b610f61565b005b348015610347575f80fd5b50610350610fc1565b60405161035d9190612795565b60405180910390f35b348015610371575f80fd5b5061037a610fe6565b005b348015610387575f80fd5b50610390610ff9565b60405161039d9190612455565b60405180910390f35b3480156103b1575f80fd5b506103cc60048036038101906103c7919061275b565b610fff565b005b3480156103d9575f80fd5b506103e2611011565b6040516103ef9190612455565b60405180910390f35b348015610403575f80fd5b5061041e6004803603810190610419919061246e565b611017565b005b34801561042b575f80fd5b5061043461123c565b6040516104419190612795565b60405180910390f35b348015610455575f80fd5b50610470600480360381019061046b919061246e565b611263565b60405161047d9190612825565b60405180910390f35b348015610491575f80fd5b506104ac60048036038101906104a7919061283e565b611280565b005b3480156104b9575f80fd5b506104d460048036038101906104cf919061246e565b61130f565b6040516104e19190612795565b60405180910390f35b3480156104f5575f80fd5b50610510600480360381019061050b919061287c565b61133f565b60405161051d9190612795565b60405180910390f35b348015610531575f80fd5b5061054c600480360381019061054791906128a7565b61136f565b6040516105599190612455565b60405180910390f35b34801561056d575f80fd5b506105886004803603810190610583919061275b565b611570565b005b348015610595575f80fd5b5061059e611582565b6040516105ab9190612455565b60405180910390f35b3480156105bf575f80fd5b506105da60048036038101906105d59190612a33565b61158e565b005b3480156105e7575f80fd5b5061060260048036038101906105fd919061246e565b6117fa565b60405161061193929190612ad5565b60405180910390f35b348015610625575f80fd5b50610640600480360381019061063b919061275b565b6118d1565b005b34801561064d575f80fd5b506106686004803603810190610663919061246e565b611927565b005b6106726119ab565b3073ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16146106e0576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016106d790612b5b565b60405180910390fd5b5f8590505f8173ffffffffffffffffffffffffffffffffffffffff16630dfe16816040518163ffffffff1660e01b8152600401602060405180830381865afa15801561072e573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906107529190612b8d565b90505f8273ffffffffffffffffffffffffffffffffffffffff1663d21220a76040518163ffffffff1660e01b8152600401602060405180830381865afa15801561079e573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906107c29190612b8d565b905060085f8373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f9054906101000a900460ff161580610861575060085f8273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f9054906101000a900460ff16155b156108a1576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161089890612c02565b60405180910390fd5b5f805f808a1180156108b257505f87115b156108c557849250839150899050610922565b5f891180156108d357505f88115b156108e657839250849150889050610921565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161091890612c6a565b60405180910390fd5b5b6006548111156109325760065490505b5f61093c8c6119f1565b90505f73ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff16036109ac576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016109a390612cd2565b60405180910390fd5b5f805f6109bb86888787611be4565b9250925092506007546005546109d19190612d1d565b811015610a0a576040517f4e47f8ea00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f8673ffffffffffffffffffffffffffffffffffffffff166370a08231306040518263ffffffff1660e01b8152600401610a449190612795565b602060405180830381865afa158015610a5f573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610a839190612d64565b90505f8103610ac7576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610abe90612dd9565b60405180910390fd5b5f868210610ad55786610ad7565b815b9050610ae685898b8488611d99565b8773ffffffffffffffffffffffffffffffffffffffff168573ffffffffffffffffffffffffffffffffffffffff168773ffffffffffffffffffffffffffffffffffffffff167f9fdefc319d5b857fa8ec2d985b19e06aa8e5b47517c20119b640ef7eb642d00d8c8588604051610b5e93929190612df7565b60405180910390a4505050505050505050505050610b7a611fca565b5050505050565b60065481565b610b8f6122fa565b60035f8373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f206040518060600160405290815f82015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001600182018054610c3b90612e59565b80601f0160208091040260200160405190810160405280929190818152602001828054610c6790612e59565b8015610cb25780601f10610c8957610100808354040283529160200191610cb2565b820191905f5260205f20905b815481529060010190602001808311610c9557829003601f168201915b50505050508152602001600282015f9054906101000a900460ff1615151515815250509050919050565b610ce4611fd3565b8060025f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555050565b60025f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614610dad576040517f5c427cd900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f855f1c90505f855f1c90506080848490501015610df7576040517fac66c1e900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f805f808787810190610e0a9190612e89565b9350935093509350610e1f8d8585858561205a565b50505050505050505050505050565b610e36611fd3565b5f610e41858561219e565b90508260095f8381526020019081526020015f205f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555081600a5f8573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055505050505050565b610f1c611fd3565b8060068190555050565b60048181548110610f35575f80fd5b905f5260205f20015f915054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b610f69611fd3565b8060085f8473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f6101000a81548160ff0219169083151502179055505050565b60025f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b610fee611fd3565b610ff75f612232565b565b60055481565b611007611fd3565b8060078190555050565b60075481565b61101f611fd3565b5f60035f8373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f206002015f6101000a81548160ff0219169083151502179055505f5b6004805490508110156111f5578173ffffffffffffffffffffffffffffffffffffffff16600482815481106110b0576110af612eed565b5b905f5260205f20015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16036111e257600460016004805490506111079190612f1a565b8154811061111857611117612eed565b5b905f5260205f20015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff166004828154811061115457611153612eed565b5b905f5260205f20015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555060048054806111ab576111aa612f4d565b5b600190038181905f5260205f20015f6101000a81549073ffffffffffffffffffffffffffffffffffffffff021916905590556111f5565b80806111ed90612f7a565b915050611078565b508073ffffffffffffffffffffffffffffffffffffffff167f1921ba6698157d491d41801286e9e17aee1c25965119e55403ba396b104b95db60405160405180910390a250565b5f805f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b6008602052805f5260405f205f915054906101000a900460ff1681565b611288611fd3565b8173ffffffffffffffffffffffffffffffffffffffff1663a9059cbb6112ac61123c565b836040518363ffffffff1660e01b81526004016112ca929190612fc1565b6020604051808303815f875af11580156112e6573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061130a9190612ffc565b505050565b600a602052805f5260405f205f915054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b6009602052805f5260405f205f915054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b5f3073ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16146113de576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016113d590612b5b565b60405180910390fd5b5f600267ffffffffffffffff8111156113fa576113f961290f565b5b6040519080825280602002602001820160405280156114285781602001602082028036833780820191505090505b50905084815f8151811061143f5761143e612eed565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff1681525050838160018151811061148e5761148d612eed565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff16815250505f8673ffffffffffffffffffffffffffffffffffffffff1663d06ca61f85846040518363ffffffff1660e01b81526004016115049291906130cf565b5f60405180830381865afa15801561151e573d5f803e3d5ffd5b505050506040513d5f823e3d601f19601f8201168201806040525081019061154691906131bd565b90508060018151811061155c5761155b612eed565b5b602002602001015192505050949350505050565b611578611fd3565b8060058190555050565b5f600480549050905090565b611596611fd3565b5f73ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff1614806115d057505f8151145b15611607576040517fb62d9bd800000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f60035f8473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f20600101805461165390612e59565b9050036116bb57600482908060018154018082558091505060019003905f5260205f20015f9091909190916101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055505b60405180606001604052808373ffffffffffffffffffffffffffffffffffffffff1681526020018281526020016001151581525060035f8473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f820151815f015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550602082015181600101908161178591906133a1565b506040820151816002015f6101000a81548160ff0219169083151502179055509050508173ffffffffffffffffffffffffffffffffffffffff167fc4050e82e850253f4929bdbcd143eef487be2fad64739a4f3859e5143745b832826040516117ee9190613470565b60405180910390a25050565b6003602052805f5260405f205f91509050805f015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff169080600101805461183e90612e59565b80601f016020809104026020016040519081016040528092919081815260200182805461186a90612e59565b80156118b55780601f1061188c576101008083540402835291602001916118b5565b820191905f5260205f20905b81548152906001019060200180831161189857829003601f168201915b505050505090806002015f9054906101000a900460ff16905083565b6118d9611fd3565b6118e161123c565b73ffffffffffffffffffffffffffffffffffffffff166108fc8290811502906040515f60405180830381858888f19350505050158015611923573d5f803e3d5ffd5b5050565b61192f611fd3565b5f73ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff160361199f575f6040517f1e4fbdf70000000000000000000000000000000000000000000000000000000081526004016119969190612795565b60405180910390fd5b6119a881612232565b50565b6002600154036119e7576040517f3ee5aeb500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6002600181905550565b5f80600a5f8473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1690505f73ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1614158015611ad7575060035f8273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f206002015f9054906101000a900460ff165b15611ae55780915050611bdf565b5f5b600480549050811015611bd95760035f60048381548110611b0b57611b0a612eed565b5b905f5260205f20015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f206002015f9054906101000a900460ff1615611bc65760048181548110611b9557611b94612eed565b5b905f5260205f20015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1692505050611bdf565b8080611bd190612f7a565b915050611ae7565b505f9150505b919050565b5f805f8091505f92505f90505f5b600480549050811015611d8e575f60048281548110611c1457611c13612eed565b5b905f5260205f20015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905060035f8273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f206002015f9054906101000a900460ff161580611cc257508573ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff16145b15611ccd5750611d7b565b3073ffffffffffffffffffffffffffffffffffffffff1663b663bce4828b8b8b6040518563ffffffff1660e01b8152600401611d0c9493929190613490565b602060405180830381865afa925050508015611d4657506040513d601f19601f82011682018060405250810190611d439190612d64565b60015b611d505750611d7b565b8481118015611d5e57508781115b15611d78578094508195508781611d759190612f1a565b93505b50505b8080611d8690612f7a565b915050611bf2565b509450945094915050565b8373ffffffffffffffffffffffffffffffffffffffff1663095ea7b386846040518363ffffffff1660e01b8152600401611dd4929190612fc1565b6020604051808303815f875af1158015611df0573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190611e149190612ffc565b505f600267ffffffffffffffff811115611e3157611e3061290f565b5b604051908082528060200260200182016040528015611e5f5781602001602082028036833780820191505090505b50905084815f81518110611e7657611e75612eed565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff16815250508381600181518110611ec557611ec4612eed565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff16815250508573ffffffffffffffffffffffffffffffffffffffff166338ed17398484843061012c42611f2d9190612d1d565b6040518663ffffffff1660e01b8152600401611f4d9594939291906134d3565b5f604051808303815f875af1925050508015611f8b57506040513d5f823e3d601f19601f82011682018060405250810190611f8891906131bd565b60015b611fc1576040517fce074e5700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b50505050505050565b60018081905550565b611fdb6122f3565b73ffffffffffffffffffffffffffffffffffffffff16611ff961123c565b73ffffffffffffffffffffffffffffffffffffffff16146120585761201c6122f3565b6040517f118cdaa700000000000000000000000000000000000000000000000000000000815260040161204f9190612795565b60405180910390fd5b565b3073ffffffffffffffffffffffffffffffffffffffff1663095bf92386868686866040518663ffffffff1660e01b815260040161209b95949392919061352b565b5f604051808303815f87803b1580156120b2575f80fd5b505af19250505080156120c3575060015b612196576120cf613588565b806308c379a00361214257506120e36135a7565b806120ee5750612144565b8573ffffffffffffffffffffffffffffffffffffffff167f1eb7e96e616d0030b650f858d8263ccaf2db088e29a04f016f8eaf9a652f6d2c826040516121349190613470565b60405180910390a250612191565b505b8473ffffffffffffffffffffffffffffffffffffffff167f1eb7e96e616d0030b650f858d8263ccaf2db088e29a04f016f8eaf9a652f6d2c60405161218890613680565b60405180910390a25b612197565b5b5050505050565b5f8173ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff16106122005781836040516020016121e592919061369e565b6040516020818303038152906040528051906020012061222a565b828260405160200161221392919061369e565b604051602081830303815290604052805190602001205b905092915050565b5f805f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050815f806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508173ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a35050565b5f33905090565b60405180606001604052805f73ffffffffffffffffffffffffffffffffffffffff168152602001606081526020015f151581525090565b5f604051905090565b5f80fd5b5f80fd5b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f61236b82612342565b9050919050565b61237b81612361565b8114612385575f80fd5b50565b5f8135905061239681612372565b92915050565b5f819050919050565b6123ae8161239c565b81146123b8575f80fd5b50565b5f813590506123c9816123a5565b92915050565b5f805f805f60a086880312156123e8576123e761233a565b5b5f6123f588828901612388565b9550506020612406888289016123bb565b9450506040612417888289016123bb565b9350506060612428888289016123bb565b9250506080612439888289016123bb565b9150509295509295909350565b61244f8161239c565b82525050565b5f6020820190506124685f830184612446565b92915050565b5f602082840312156124835761248261233a565b5b5f61249084828501612388565b91505092915050565b6124a281612361565b82525050565b5f81519050919050565b5f82825260208201905092915050565b5f5b838110156124df5780820151818401526020810190506124c4565b5f8484015250505050565b5f601f19601f8301169050919050565b5f612504826124a8565b61250e81856124b2565b935061251e8185602086016124c2565b612527816124ea565b840191505092915050565b5f8115159050919050565b61254681612532565b82525050565b5f606083015f8301516125615f860182612499565b506020830151848203602086015261257982826124fa565b915050604083015161258e604086018261253d565b508091505092915050565b5f6020820190508181035f8301526125b1818461254c565b905092915050565b5f819050919050565b6125cb816125b9565b81146125d5575f80fd5b50565b5f813590506125e6816125c2565b92915050565b5f80fd5b5f80fd5b5f80fd5b5f8083601f84011261260d5761260c6125ec565b5b8235905067ffffffffffffffff81111561262a576126296125f0565b5b602083019150836001820283011115612646576126456125f4565b5b9250929050565b5f805f805f805f60c0888a0312156126685761266761233a565b5b5f6126758a828b01612388565b97505060206126868a828b016125d8565b96505060406126978a828b016125d8565b95505060606126a88a828b016125d8565b94505060806126b98a828b016125d8565b93505060a088013567ffffffffffffffff8111156126da576126d961233e565b5b6126e68a828b016125f8565b925092505092959891949750929550565b5f805f806080858703121561270f5761270e61233a565b5b5f61271c87828801612388565b945050602061272d87828801612388565b935050604061273e87828801612388565b925050606061274f87828801612388565b91505092959194509250565b5f602082840312156127705761276f61233a565b5b5f61277d848285016123bb565b91505092915050565b61278f81612361565b82525050565b5f6020820190506127a85f830184612786565b92915050565b6127b781612532565b81146127c1575f80fd5b50565b5f813590506127d2816127ae565b92915050565b5f80604083850312156127ee576127ed61233a565b5b5f6127fb85828601612388565b925050602061280c858286016127c4565b9150509250929050565b61281f81612532565b82525050565b5f6020820190506128385f830184612816565b92915050565b5f80604083850312156128545761285361233a565b5b5f61286185828601612388565b9250506020612872858286016123bb565b9150509250929050565b5f602082840312156128915761289061233a565b5b5f61289e848285016125d8565b91505092915050565b5f805f80608085870312156128bf576128be61233a565b5b5f6128cc87828801612388565b94505060206128dd87828801612388565b93505060406128ee87828801612388565b92505060606128ff878288016123bb565b91505092959194509250565b5f80fd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b612945826124ea565b810181811067ffffffffffffffff821117156129645761296361290f565b5b80604052505050565b5f612976612331565b9050612982828261293c565b919050565b5f67ffffffffffffffff8211156129a1576129a061290f565b5b6129aa826124ea565b9050602081019050919050565b828183375f83830152505050565b5f6129d76129d284612987565b61296d565b9050828152602081018484840111156129f3576129f261290b565b5b6129fe8482856129b7565b509392505050565b5f82601f830112612a1a57612a196125ec565b5b8135612a2a8482602086016129c5565b91505092915050565b5f8060408385031215612a4957612a4861233a565b5b5f612a5685828601612388565b925050602083013567ffffffffffffffff811115612a7757612a7661233e565b5b612a8385828601612a06565b9150509250929050565b5f82825260208201905092915050565b5f612aa7826124a8565b612ab18185612a8d565b9350612ac18185602086016124c2565b612aca816124ea565b840191505092915050565b5f606082019050612ae85f830186612786565b8181036020830152612afa8185612a9d565b9050612b096040830184612816565b949350505050565b7f496e7465726e616c206f6e6c79000000000000000000000000000000000000005f82015250565b5f612b45600d83612a8d565b9150612b5082612b11565b602082019050919050565b5f6020820190508181035f830152612b7281612b39565b9050919050565b5f81519050612b8781612372565b92915050565b5f60208284031215612ba257612ba161233a565b5b5f612baf84828501612b79565b91505092915050565b7f556e617574686f72697a656420746f6b656e73000000000000000000000000005f82015250565b5f612bec601383612a8d565b9150612bf782612bb8565b602082019050919050565b5f6020820190508181035f830152612c1981612be0565b9050919050565b7f496e76616c6964207377617020616d6f756e74730000000000000000000000005f82015250565b5f612c54601483612a8d565b9150612c5f82612c20565b602082019050919050565b5f6020820190508181035f830152612c8181612c48565b9050919050565b7f5072696d61727920444558206e6f7420666f756e6400000000000000000000005f82015250565b5f612cbc601583612a8d565b9150612cc782612c88565b602082019050919050565b5f6020820190508181035f830152612ce981612cb0565b9050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f612d278261239c565b9150612d328361239c565b9250828201905080821115612d4a57612d49612cf0565b5b92915050565b5f81519050612d5e816123a5565b92915050565b5f60208284031215612d7957612d7861233a565b5b5f612d8684828501612d50565b91505092915050565b7f4e6f2062616c616e636520666f722061726269747261676500000000000000005f82015250565b5f612dc3601883612a8d565b9150612dce82612d8f565b602082019050919050565b5f6020820190508181035f830152612df081612db7565b9050919050565b5f606082019050612e0a5f830186612786565b612e176020830185612446565b612e246040830184612446565b949350505050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602260045260245ffd5b5f6002820490506001821680612e7057607f821691505b602082108103612e8357612e82612e2c565b5b50919050565b5f805f8060808587031215612ea157612ea061233a565b5b5f612eae878288016123bb565b9450506020612ebf878288016123bb565b9350506040612ed0878288016123bb565b9250506060612ee1878288016123bb565b91505092959194509250565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b5f612f248261239c565b9150612f2f8361239c565b9250828203905081811115612f4757612f46612cf0565b5b92915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603160045260245ffd5b5f612f848261239c565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203612fb657612fb5612cf0565b5b600182019050919050565b5f604082019050612fd45f830185612786565b612fe16020830184612446565b9392505050565b5f81519050612ff6816127ae565b92915050565b5f602082840312156130115761301061233a565b5b5f61301e84828501612fe8565b91505092915050565b5f81519050919050565b5f82825260208201905092915050565b5f819050602082019050919050565b5f61305b8383612499565b60208301905092915050565b5f602082019050919050565b5f61307d82613027565b6130878185613031565b935061309283613041565b805f5b838110156130c25781516130a98882613050565b97506130b483613067565b925050600181019050613095565b5085935050505092915050565b5f6040820190506130e25f830185612446565b81810360208301526130f48184613073565b90509392505050565b5f67ffffffffffffffff8211156131175761311661290f565b5b602082029050602081019050919050565b5f61313a613135846130fd565b61296d565b9050808382526020820190506020840283018581111561315d5761315c6125f4565b5b835b8181101561318657806131728882612d50565b84526020840193505060208101905061315f565b5050509392505050565b5f82601f8301126131a4576131a36125ec565b5b81516131b4848260208601613128565b91505092915050565b5f602082840312156131d2576131d161233a565b5b5f82015167ffffffffffffffff8111156131ef576131ee61233e565b5b6131fb84828501613190565b91505092915050565b5f819050815f5260205f209050919050565b5f6020601f8301049050919050565b5f82821b905092915050565b5f600883026132607fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82613225565b61326a8683613225565b95508019841693508086168417925050509392505050565b5f819050919050565b5f6132a56132a061329b8461239c565b613282565b61239c565b9050919050565b5f819050919050565b6132be8361328b565b6132d26132ca826132ac565b848454613231565b825550505050565b5f90565b6132e66132da565b6132f18184846132b5565b505050565b5b81811015613314576133095f826132de565b6001810190506132f7565b5050565b601f8211156133595761332a81613204565b61333384613216565b81016020851015613342578190505b61335661334e85613216565b8301826132f6565b50505b505050565b5f82821c905092915050565b5f6133795f198460080261335e565b1980831691505092915050565b5f613391838361336a565b9150826002028217905092915050565b6133aa826124a8565b67ffffffffffffffff8111156133c3576133c261290f565b5b6133cd8254612e59565b6133d8828285613318565b5f60209050601f831160018114613409575f84156133f7578287015190505b6134018582613386565b865550613468565b601f19841661341786613204565b5f5b8281101561343e57848901518255600182019150602085019450602081019050613419565b8683101561345b5784890151613457601f89168261336a565b8355505b6001600288020188555050505b505050505050565b5f6020820190508181035f8301526134888184612a9d565b905092915050565b5f6080820190506134a35f830187612786565b6134b06020830186612786565b6134bd6040830185612786565b6134ca6060830184612446565b95945050505050565b5f60a0820190506134e65f830188612446565b6134f36020830187612446565b81810360408301526135058186613073565b90506135146060830185612786565b6135216080830184612446565b9695505050505050565b5f60a08201905061353e5f830188612786565b61354b6020830187612446565b6135586040830186612446565b6135656060830185612446565b6135726080830184612446565b9695505050505050565b5f8160e01c9050919050565b5f60033d11156135a45760045f803e6135a15f5161357c565b90505b90565b5f60443d10613633576135b8612331565b60043d036004823e80513d602482011167ffffffffffffffff821117156135e0575050613633565b808201805167ffffffffffffffff8111156135fe5750505050613633565b80602083010160043d03850181111561361b575050505050613633565b61362a8260200185018661293c565b82955050505050505b90565b7f556e6b6e6f776e206572726f72000000000000000000000000000000000000005f82015250565b5f61366a600d83612a8d565b915061367582613636565b602082019050919050565b5f6020820190508181035f8301526136978161365e565b9050919050565b5f6040820190506136b15f830185612786565b6136be6020830184612786565b939250505056fea26469706673582212204c5a56888531076855db2313d6ed0ecc887d5f2bbe22b4de2958f38f33b26dd964736f6c63430008140033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@ReZ\xF3\x10z@\0`\x05Ug\x8A\xC7#\x04\x89\xE8\0\0`\x06Uf#\x86\xF2o\xC1\0\0`\x07U4\x80\x15b\0\x001W_\x80\xFD[P3_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x03b\0\0\xA6W_`@Q\x7F\x1EO\xBD\xF7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01b\0\0\x9D\x91\x90b\0\x01\xC9V[`@Q\x80\x91\x03\x90\xFD[b\0\0\xB7\x81b\0\0\xC5` \x1B` \x1CV[P`\x01\x80\x81\x90UPb\0\x01\xE4V[_\x80_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x81_\x80a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\x8B\xE0\x07\x9CS\x16Y\x14\x13D\xCD\x1F\xD0\xA4\xF2\x84\x19I\x7F\x97\"\xA3\xDA\xAF\xE3\xB4\x18okdW\xE0`@Q`@Q\x80\x91\x03\x90\xA3PPV[_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[_b\0\x01\xB1\x82b\0\x01\x86V[\x90P\x91\x90PV[b\0\x01\xC3\x81b\0\x01\xA5V[\x82RPPV[_` \x82\x01\x90Pb\0\x01\xDE_\x83\x01\x84b\0\x01\xB8V[\x92\x91PPV[a6\xFB\x80b\0\x01\xF2_9_\xF3\xFE`\x80`@R`\x046\x10a\x01\x9FW_5`\xE0\x1C\x80c\x89\x86\"\xE8\x11a\0\xEBW\x80c\xB6c\xBC\xE4\x11a\0\x89W\x80c\xDC\xBEC\xD9\x11a\0cW\x80c\xDC\xBEC\xD9\x14a\x05\xB4W\x80c\xE7\xC2&\x9E\x14a\x05\xDCW\x80c\xF1B\x10\xA6\x14a\x06\x1AW\x80c\xF2\xFD\xE3\x8B\x14a\x06BWa\x01\xA6V[\x80c\xB6c\xBC\xE4\x14a\x05&W\x80c\xC0(de\x14a\x05bW\x80c\xD6\xB2\xAB$\x14a\x05\x8AWa\x01\xA6V[\x80c\x9B\xC7\xC5\x86\x11a\0\xC5W\x80c\x9B\xC7\xC5\x86\x14a\x04JW\x80c\x9E(\x1A\x98\x14a\x04\x86W\x80c\xAC<4\xB8\x14a\x04\xAEW\x80c\xAD\xB7\t*\x14a\x04\xEAWa\x01\xA6V[\x80c\x89\x86\"\xE8\x14a\x03\xCEW\x80c\x8C\x8F?\x82\x14a\x03\xF8W\x80c\x8D\xA5\xCB[\x14a\x04 Wa\x01\xA6V[\x80cK?3x\x11a\x01XW\x80c\\\x1B\xBA8\x11a\x012W\x80c\\\x1B\xBA8\x14a\x03<W\x80cqP\x18\xA6\x14a\x03fW\x80csA\xAB\x8C\x14a\x03|W\x80c\x82\xCCim\x14a\x03\xA6Wa\x01\xA6V[\x80cK?3x\x14a\x02\xB0W\x80cL\xAF\x81\xF5\x14a\x02\xD8W\x80cS\xFC\x83\x8B\x14a\x03\x14Wa\x01\xA6V[\x80c\t[\xF9#\x14a\x01\xAAW\x80c\x10\xFAy\xE2\x14a\x01\xD2W\x80c\x16\x1E\xFBb\x14a\x01\xFCW\x80c%G\xFA>\x14a\x028W\x80c>\xA6\xF2\x07\x14a\x02`W\x80c?\x8A4g\x14a\x02\x88Wa\x01\xA6V[6a\x01\xA6W\0[_\x80\xFD[4\x80\x15a\x01\xB5W_\x80\xFD[Pa\x01\xD0`\x04\x806\x03\x81\x01\x90a\x01\xCB\x91\x90a#\xCFV[a\x06jV[\0[4\x80\x15a\x01\xDDW_\x80\xFD[Pa\x01\xE6a\x0B\x81V[`@Qa\x01\xF3\x91\x90a$UV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02\x07W_\x80\xFD[Pa\x02\"`\x04\x806\x03\x81\x01\x90a\x02\x1D\x91\x90a$nV[a\x0B\x87V[`@Qa\x02/\x91\x90a%\x99V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02CW_\x80\xFD[Pa\x02^`\x04\x806\x03\x81\x01\x90a\x02Y\x91\x90a$nV[a\x0C\xDCV[\0[4\x80\x15a\x02kW_\x80\xFD[Pa\x02\x86`\x04\x806\x03\x81\x01\x90a\x02\x81\x91\x90a&MV[a\r'V[\0[4\x80\x15a\x02\x93W_\x80\xFD[Pa\x02\xAE`\x04\x806\x03\x81\x01\x90a\x02\xA9\x91\x90a&\xF7V[a\x0E.V[\0[4\x80\x15a\x02\xBBW_\x80\xFD[Pa\x02\xD6`\x04\x806\x03\x81\x01\x90a\x02\xD1\x91\x90a'[V[a\x0F\x14V[\0[4\x80\x15a\x02\xE3W_\x80\xFD[Pa\x02\xFE`\x04\x806\x03\x81\x01\x90a\x02\xF9\x91\x90a'[V[a\x0F&V[`@Qa\x03\x0B\x91\x90a'\x95V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03\x1FW_\x80\xFD[Pa\x03:`\x04\x806\x03\x81\x01\x90a\x035\x91\x90a'\xD8V[a\x0FaV[\0[4\x80\x15a\x03GW_\x80\xFD[Pa\x03Pa\x0F\xC1V[`@Qa\x03]\x91\x90a'\x95V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03qW_\x80\xFD[Pa\x03za\x0F\xE6V[\0[4\x80\x15a\x03\x87W_\x80\xFD[Pa\x03\x90a\x0F\xF9V[`@Qa\x03\x9D\x91\x90a$UV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03\xB1W_\x80\xFD[Pa\x03\xCC`\x04\x806\x03\x81\x01\x90a\x03\xC7\x91\x90a'[V[a\x0F\xFFV[\0[4\x80\x15a\x03\xD9W_\x80\xFD[Pa\x03\xE2a\x10\x11V[`@Qa\x03\xEF\x91\x90a$UV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04\x03W_\x80\xFD[Pa\x04\x1E`\x04\x806\x03\x81\x01\x90a\x04\x19\x91\x90a$nV[a\x10\x17V[\0[4\x80\x15a\x04+W_\x80\xFD[Pa\x044a\x12<V[`@Qa\x04A\x91\x90a'\x95V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04UW_\x80\xFD[Pa\x04p`\x04\x806\x03\x81\x01\x90a\x04k\x91\x90a$nV[a\x12cV[`@Qa\x04}\x91\x90a(%V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04\x91W_\x80\xFD[Pa\x04\xAC`\x04\x806\x03\x81\x01\x90a\x04\xA7\x91\x90a(>V[a\x12\x80V[\0[4\x80\x15a\x04\xB9W_\x80\xFD[Pa\x04\xD4`\x04\x806\x03\x81\x01\x90a\x04\xCF\x91\x90a$nV[a\x13\x0FV[`@Qa\x04\xE1\x91\x90a'\x95V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04\xF5W_\x80\xFD[Pa\x05\x10`\x04\x806\x03\x81\x01\x90a\x05\x0B\x91\x90a(|V[a\x13?V[`@Qa\x05\x1D\x91\x90a'\x95V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x051W_\x80\xFD[Pa\x05L`\x04\x806\x03\x81\x01\x90a\x05G\x91\x90a(\xA7V[a\x13oV[`@Qa\x05Y\x91\x90a$UV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x05mW_\x80\xFD[Pa\x05\x88`\x04\x806\x03\x81\x01\x90a\x05\x83\x91\x90a'[V[a\x15pV[\0[4\x80\x15a\x05\x95W_\x80\xFD[Pa\x05\x9Ea\x15\x82V[`@Qa\x05\xAB\x91\x90a$UV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x05\xBFW_\x80\xFD[Pa\x05\xDA`\x04\x806\x03\x81\x01\x90a\x05\xD5\x91\x90a*3V[a\x15\x8EV[\0[4\x80\x15a\x05\xE7W_\x80\xFD[Pa\x06\x02`\x04\x806\x03\x81\x01\x90a\x05\xFD\x91\x90a$nV[a\x17\xFAV[`@Qa\x06\x11\x93\x92\x91\x90a*\xD5V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x06%W_\x80\xFD[Pa\x06@`\x04\x806\x03\x81\x01\x90a\x06;\x91\x90a'[V[a\x18\xD1V[\0[4\x80\x15a\x06MW_\x80\xFD[Pa\x06h`\x04\x806\x03\x81\x01\x90a\x06c\x91\x90a$nV[a\x19'V[\0[a\x06ra\x19\xABV[0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x06\xE0W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x06\xD7\x90a+[V[`@Q\x80\x91\x03\x90\xFD[_\x85\x90P_\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\r\xFE\x16\x81`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x07.W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x07R\x91\x90a+\x8DV[\x90P_\x82s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xD2\x12 \xA7`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x07\x9EW=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x07\xC2\x91\x90a+\x8DV[\x90P`\x08_\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x15\x80a\x08aWP`\x08_\x82s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x15[\x15a\x08\xA1W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x08\x98\x90a,\x02V[`@Q\x80\x91\x03\x90\xFD[_\x80_\x80\x8A\x11\x80\x15a\x08\xB2WP_\x87\x11[\x15a\x08\xC5W\x84\x92P\x83\x91P\x89\x90Pa\t\"V[_\x89\x11\x80\x15a\x08\xD3WP_\x88\x11[\x15a\x08\xE6W\x83\x92P\x84\x91P\x88\x90Pa\t!V[`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\t\x18\x90a,jV[`@Q\x80\x91\x03\x90\xFD[[`\x06T\x81\x11\x15a\t2W`\x06T\x90P[_a\t<\x8Ca\x19\xF1V[\x90P_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x03a\t\xACW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\t\xA3\x90a,\xD2V[`@Q\x80\x91\x03\x90\xFD[_\x80_a\t\xBB\x86\x88\x87\x87a\x1B\xE4V[\x92P\x92P\x92P`\x07T`\x05Ta\t\xD1\x91\x90a-\x1DV[\x81\x10\x15a\n\nW`@Q\x7FNG\xF8\xEA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x86s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16cp\xA0\x8210`@Q\x82c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\nD\x91\x90a'\x95V[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\n_W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\n\x83\x91\x90a-dV[\x90P_\x81\x03a\n\xC7W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\n\xBE\x90a-\xD9V[`@Q\x80\x91\x03\x90\xFD[_\x86\x82\x10a\n\xD5W\x86a\n\xD7V[\x81[\x90Pa\n\xE6\x85\x89\x8B\x84\x88a\x1D\x99V[\x87s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x85s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x87s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\x9F\xDE\xFC1\x9D[\x85\x7F\xA8\xEC-\x98[\x19\xE0j\xA8\xE5\xB4u\x17\xC2\x01\x19\xB6@\xEF~\xB6B\xD0\r\x8C\x85\x88`@Qa\x0B^\x93\x92\x91\x90a-\xF7V[`@Q\x80\x91\x03\x90\xA4PPPPPPPPPPPPa\x0Bza\x1F\xCAV[PPPPPV[`\x06T\x81V[a\x0B\x8Fa\"\xFAV[`\x03_\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ `@Q\x80``\x01`@R\x90\x81_\x82\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01`\x01\x82\x01\x80Ta\x0C;\x90a.YV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x0Cg\x90a.YV[\x80\x15a\x0C\xB2W\x80`\x1F\x10a\x0C\x89Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x0C\xB2V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x0C\x95W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x02\x82\x01_\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x15\x15\x15\x15\x81RPP\x90P\x91\x90PV[a\x0C\xE4a\x1F\xD3V[\x80`\x02_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UPPV[`\x02_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\r\xADW`@Q\x7F\\B|\xD9\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x85_\x1C\x90P_\x85_\x1C\x90P`\x80\x84\x84\x90P\x10\x15a\r\xF7W`@Q\x7F\xACf\xC1\xE9\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x80_\x80\x87\x87\x81\x01\x90a\x0E\n\x91\x90a.\x89V[\x93P\x93P\x93P\x93Pa\x0E\x1F\x8D\x85\x85\x85\x85a ZV[PPPPPPPPPPPPPV[a\x0E6a\x1F\xD3V[_a\x0EA\x85\x85a!\x9EV[\x90P\x82`\t_\x83\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP\x81`\n_\x85s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UPPPPPPV[a\x0F\x1Ca\x1F\xD3V[\x80`\x06\x81\x90UPPV[`\x04\x81\x81T\x81\x10a\x0F5W_\x80\xFD[\x90_R` _ \x01_\x91PT\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81V[a\x0Fia\x1F\xD3V[\x80`\x08_\x84s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UPPPV[`\x02_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81V[a\x0F\xEEa\x1F\xD3V[a\x0F\xF7_a\"2V[V[`\x05T\x81V[a\x10\x07a\x1F\xD3V[\x80`\x07\x81\x90UPPV[`\x07T\x81V[a\x10\x1Fa\x1F\xD3V[_`\x03_\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ `\x02\x01_a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP_[`\x04\x80T\x90P\x81\x10\x15a\x11\xF5W\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`\x04\x82\x81T\x81\x10a\x10\xB0Wa\x10\xAFa.\xEDV[[\x90_R` _ \x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x03a\x11\xE2W`\x04`\x01`\x04\x80T\x90Pa\x11\x07\x91\x90a/\x1AV[\x81T\x81\x10a\x11\x18Wa\x11\x17a.\xEDV[[\x90_R` _ \x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`\x04\x82\x81T\x81\x10a\x11TWa\x11Sa.\xEDV[[\x90_R` _ \x01_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP`\x04\x80T\x80a\x11\xABWa\x11\xAAa/MV[[`\x01\x90\x03\x81\x81\x90_R` _ \x01_a\x01\0\n\x81T\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90U\x90Ua\x11\xF5V[\x80\x80a\x11\xED\x90a/zV[\x91PPa\x10xV[P\x80s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\x19!\xBAf\x98\x15}I\x1DA\x80\x12\x86\xE9\xE1z\xEE\x1C%\x96Q\x19\xE5T\x03\xBA9k\x10K\x95\xDB`@Q`@Q\x80\x91\x03\x90\xA2PV[_\x80_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x90V[`\x08` R\x80_R`@_ _\x91PT\x90a\x01\0\n\x90\x04`\xFF\x16\x81V[a\x12\x88a\x1F\xD3V[\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xA9\x05\x9C\xBBa\x12\xACa\x12<V[\x83`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x12\xCA\x92\x91\x90a/\xC1V[` `@Q\x80\x83\x03\x81_\x87Z\xF1\x15\x80\x15a\x12\xE6W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x13\n\x91\x90a/\xFCV[PPPV[`\n` R\x80_R`@_ _\x91PT\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81V[`\t` R\x80_R`@_ _\x91PT\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81V[_0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x13\xDEW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x13\xD5\x90a+[V[`@Q\x80\x91\x03\x90\xFD[_`\x02g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x13\xFAWa\x13\xF9a)\x0FV[[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\x14(W\x81` \x01` \x82\x02\x806\x837\x80\x82\x01\x91PP\x90P[P\x90P\x84\x81_\x81Q\x81\x10a\x14?Wa\x14>a.\xEDV[[` \x02` \x01\x01\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81RPP\x83\x81`\x01\x81Q\x81\x10a\x14\x8EWa\x14\x8Da.\xEDV[[` \x02` \x01\x01\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81RPP_\x86s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xD0l\xA6\x1F\x85\x84`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x15\x04\x92\x91\x90a0\xCFV[_`@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x15\x1EW=_\x80>=_\xFD[PPPP`@Q=_\x82>=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x15F\x91\x90a1\xBDV[\x90P\x80`\x01\x81Q\x81\x10a\x15\\Wa\x15[a.\xEDV[[` \x02` \x01\x01Q\x92PPP\x94\x93PPPPV[a\x15xa\x1F\xD3V[\x80`\x05\x81\x90UPPV[_`\x04\x80T\x90P\x90P\x90V[a\x15\x96a\x1F\xD3V[_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x82s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14\x80a\x15\xD0WP_\x81Q\x14[\x15a\x16\x07W`@Q\x7F\xB6-\x9B\xD8\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x03_\x84s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ `\x01\x01\x80Ta\x16S\x90a.YV[\x90P\x03a\x16\xBBW`\x04\x82\x90\x80`\x01\x81T\x01\x80\x82U\x80\x91PP`\x01\x90\x03\x90_R` _ \x01_\x90\x91\x90\x91\x90\x91a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP[`@Q\x80``\x01`@R\x80\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x82\x81R` \x01`\x01\x15\x15\x81RP`\x03_\x84s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _\x82\x01Q\x81_\x01_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP` \x82\x01Q\x81`\x01\x01\x90\x81a\x17\x85\x91\x90a3\xA1V[P`@\x82\x01Q\x81`\x02\x01_a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x90PP\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xC4\x05\x0E\x82\xE8P%?I)\xBD\xBC\xD1C\xEE\xF4\x87\xBE/\xADds\x9AO8Y\xE5\x147E\xB82\x82`@Qa\x17\xEE\x91\x90a4pV[`@Q\x80\x91\x03\x90\xA2PPV[`\x03` R\x80_R`@_ _\x91P\x90P\x80_\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90\x80`\x01\x01\x80Ta\x18>\x90a.YV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x18j\x90a.YV[\x80\x15a\x18\xB5W\x80`\x1F\x10a\x18\x8CWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x18\xB5V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x18\x98W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x90\x80`\x02\x01_\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x90P\x83V[a\x18\xD9a\x1F\xD3V[a\x18\xE1a\x12<V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x08\xFC\x82\x90\x81\x15\x02\x90`@Q_`@Q\x80\x83\x03\x81\x85\x88\x88\xF1\x93PPPP\x15\x80\x15a\x19#W=_\x80>=_\xFD[PPV[a\x19/a\x1F\xD3V[_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x03a\x19\x9FW_`@Q\x7F\x1EO\xBD\xF7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x19\x96\x91\x90a'\x95V[`@Q\x80\x91\x03\x90\xFD[a\x19\xA8\x81a\"2V[PV[`\x02`\x01T\x03a\x19\xE7W`@Q\x7F>\xE5\xAE\xB5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x02`\x01\x81\x90UPV[_\x80`\n_\x84s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14\x15\x80\x15a\x1A\xD7WP`\x03_\x82s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ `\x02\x01_\x90T\x90a\x01\0\n\x90\x04`\xFF\x16[\x15a\x1A\xE5W\x80\x91PPa\x1B\xDFV[_[`\x04\x80T\x90P\x81\x10\x15a\x1B\xD9W`\x03_`\x04\x83\x81T\x81\x10a\x1B\x0BWa\x1B\na.\xEDV[[\x90_R` _ \x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ `\x02\x01_\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x15a\x1B\xC6W`\x04\x81\x81T\x81\x10a\x1B\x95Wa\x1B\x94a.\xEDV[[\x90_R` _ \x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x92PPPa\x1B\xDFV[\x80\x80a\x1B\xD1\x90a/zV[\x91PPa\x1A\xE7V[P_\x91PP[\x91\x90PV[_\x80_\x80\x91P_\x92P_\x90P_[`\x04\x80T\x90P\x81\x10\x15a\x1D\x8EW_`\x04\x82\x81T\x81\x10a\x1C\x14Wa\x1C\x13a.\xEDV[[\x90_R` _ \x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P`\x03_\x82s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ `\x02\x01_\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x15\x80a\x1C\xC2WP\x85s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14[\x15a\x1C\xCDWPa\x1D{V[0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xB6c\xBC\xE4\x82\x8B\x8B\x8B`@Q\x85c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x1D\x0C\x94\x93\x92\x91\x90a4\x90V[` `@Q\x80\x83\x03\x81\x86Z\xFA\x92PPP\x80\x15a\x1DFWP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x1DC\x91\x90a-dV[`\x01[a\x1DPWPa\x1D{V[\x84\x81\x11\x80\x15a\x1D^WP\x87\x81\x11[\x15a\x1DxW\x80\x94P\x81\x95P\x87\x81a\x1Du\x91\x90a/\x1AV[\x93P[PP[\x80\x80a\x1D\x86\x90a/zV[\x91PPa\x1B\xF2V[P\x94P\x94P\x94\x91PPV[\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\t^\xA7\xB3\x86\x84`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x1D\xD4\x92\x91\x90a/\xC1V[` `@Q\x80\x83\x03\x81_\x87Z\xF1\x15\x80\x15a\x1D\xF0W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x1E\x14\x91\x90a/\xFCV[P_`\x02g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x1E1Wa\x1E0a)\x0FV[[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\x1E_W\x81` \x01` \x82\x02\x806\x837\x80\x82\x01\x91PP\x90P[P\x90P\x84\x81_\x81Q\x81\x10a\x1EvWa\x1Eua.\xEDV[[` \x02` \x01\x01\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81RPP\x83\x81`\x01\x81Q\x81\x10a\x1E\xC5Wa\x1E\xC4a.\xEDV[[` \x02` \x01\x01\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81RPP\x85s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c8\xED\x179\x84\x84\x840a\x01,Ba\x1F-\x91\x90a-\x1DV[`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x1FM\x95\x94\x93\x92\x91\x90a4\xD3V[_`@Q\x80\x83\x03\x81_\x87Z\xF1\x92PPP\x80\x15a\x1F\x8BWP`@Q=_\x82>=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x1F\x88\x91\x90a1\xBDV[`\x01[a\x1F\xC1W`@Q\x7F\xCE\x07NW\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[PPPPPPPV[`\x01\x80\x81\x90UPV[a\x1F\xDBa\"\xF3V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x1F\xF9a\x12<V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a XWa \x1Ca\"\xF3V[`@Q\x7F\x11\x8C\xDA\xA7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a O\x91\x90a'\x95V[`@Q\x80\x91\x03\x90\xFD[V[0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\t[\xF9#\x86\x86\x86\x86\x86`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a \x9B\x95\x94\x93\x92\x91\x90a5+V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a \xB2W_\x80\xFD[PZ\xF1\x92PPP\x80\x15a \xC3WP`\x01[a!\x96Wa \xCFa5\x88V[\x80c\x08\xC3y\xA0\x03a!BWPa \xE3a5\xA7V[\x80a \xEEWPa!DV[\x85s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\x1E\xB7\xE9nam\x000\xB6P\xF8X\xD8&<\xCA\xF2\xDB\x08\x8E)\xA0O\x01o\x8E\xAF\x9Ae/m,\x82`@Qa!4\x91\x90a4pV[`@Q\x80\x91\x03\x90\xA2Pa!\x91V[P[\x84s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\x1E\xB7\xE9nam\x000\xB6P\xF8X\xD8&<\xCA\xF2\xDB\x08\x8E)\xA0O\x01o\x8E\xAF\x9Ae/m,`@Qa!\x88\x90a6\x80V[`@Q\x80\x91\x03\x90\xA2[a!\x97V[[PPPPPV[_\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x10a\"\0W\x81\x83`@Q` \x01a!\xE5\x92\x91\x90a6\x9EV[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 a\"*V[\x82\x82`@Q` \x01a\"\x13\x92\x91\x90a6\x9EV[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 [\x90P\x92\x91PPV[_\x80_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x81_\x80a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\x8B\xE0\x07\x9CS\x16Y\x14\x13D\xCD\x1F\xD0\xA4\xF2\x84\x19I\x7F\x97\"\xA3\xDA\xAF\xE3\xB4\x18okdW\xE0`@Q`@Q\x80\x91\x03\x90\xA3PPV[_3\x90P\x90V[`@Q\x80``\x01`@R\x80_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01``\x81R` \x01_\x15\x15\x81RP\x90V[_`@Q\x90P\x90V[_\x80\xFD[_\x80\xFD[_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[_a#k\x82a#BV[\x90P\x91\x90PV[a#{\x81a#aV[\x81\x14a#\x85W_\x80\xFD[PV[_\x815\x90Pa#\x96\x81a#rV[\x92\x91PPV[_\x81\x90P\x91\x90PV[a#\xAE\x81a#\x9CV[\x81\x14a#\xB8W_\x80\xFD[PV[_\x815\x90Pa#\xC9\x81a#\xA5V[\x92\x91PPV[_\x80_\x80_`\xA0\x86\x88\x03\x12\x15a#\xE8Wa#\xE7a#:V[[_a#\xF5\x88\x82\x89\x01a#\x88V[\x95PP` a$\x06\x88\x82\x89\x01a#\xBBV[\x94PP`@a$\x17\x88\x82\x89\x01a#\xBBV[\x93PP``a$(\x88\x82\x89\x01a#\xBBV[\x92PP`\x80a$9\x88\x82\x89\x01a#\xBBV[\x91PP\x92\x95P\x92\x95\x90\x93PV[a$O\x81a#\x9CV[\x82RPPV[_` \x82\x01\x90Pa$h_\x83\x01\x84a$FV[\x92\x91PPV[_` \x82\x84\x03\x12\x15a$\x83Wa$\x82a#:V[[_a$\x90\x84\x82\x85\x01a#\x88V[\x91PP\x92\x91PPV[a$\xA2\x81a#aV[\x82RPPV[_\x81Q\x90P\x91\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_[\x83\x81\x10\x15a$\xDFW\x80\x82\x01Q\x81\x84\x01R` \x81\x01\x90Pa$\xC4V[_\x84\x84\x01RPPPPV[_`\x1F\x19`\x1F\x83\x01\x16\x90P\x91\x90PV[_a%\x04\x82a$\xA8V[a%\x0E\x81\x85a$\xB2V[\x93Pa%\x1E\x81\x85` \x86\x01a$\xC2V[a%'\x81a$\xEAV[\x84\x01\x91PP\x92\x91PPV[_\x81\x15\x15\x90P\x91\x90PV[a%F\x81a%2V[\x82RPPV[_``\x83\x01_\x83\x01Qa%a_\x86\x01\x82a$\x99V[P` \x83\x01Q\x84\x82\x03` \x86\x01Ra%y\x82\x82a$\xFAV[\x91PP`@\x83\x01Qa%\x8E`@\x86\x01\x82a%=V[P\x80\x91PP\x92\x91PPV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra%\xB1\x81\x84a%LV[\x90P\x92\x91PPV[_\x81\x90P\x91\x90PV[a%\xCB\x81a%\xB9V[\x81\x14a%\xD5W_\x80\xFD[PV[_\x815\x90Pa%\xE6\x81a%\xC2V[\x92\x91PPV[_\x80\xFD[_\x80\xFD[_\x80\xFD[_\x80\x83`\x1F\x84\x01\x12a&\rWa&\x0Ca%\xECV[[\x825\x90Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a&*Wa&)a%\xF0V[[` \x83\x01\x91P\x83`\x01\x82\x02\x83\x01\x11\x15a&FWa&Ea%\xF4V[[\x92P\x92\x90PV[_\x80_\x80_\x80_`\xC0\x88\x8A\x03\x12\x15a&hWa&ga#:V[[_a&u\x8A\x82\x8B\x01a#\x88V[\x97PP` a&\x86\x8A\x82\x8B\x01a%\xD8V[\x96PP`@a&\x97\x8A\x82\x8B\x01a%\xD8V[\x95PP``a&\xA8\x8A\x82\x8B\x01a%\xD8V[\x94PP`\x80a&\xB9\x8A\x82\x8B\x01a%\xD8V[\x93PP`\xA0\x88\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a&\xDAWa&\xD9a#>V[[a&\xE6\x8A\x82\x8B\x01a%\xF8V[\x92P\x92PP\x92\x95\x98\x91\x94\x97P\x92\x95PV[_\x80_\x80`\x80\x85\x87\x03\x12\x15a'\x0FWa'\x0Ea#:V[[_a'\x1C\x87\x82\x88\x01a#\x88V[\x94PP` a'-\x87\x82\x88\x01a#\x88V[\x93PP`@a'>\x87\x82\x88\x01a#\x88V[\x92PP``a'O\x87\x82\x88\x01a#\x88V[\x91PP\x92\x95\x91\x94P\x92PV[_` \x82\x84\x03\x12\x15a'pWa'oa#:V[[_a'}\x84\x82\x85\x01a#\xBBV[\x91PP\x92\x91PPV[a'\x8F\x81a#aV[\x82RPPV[_` \x82\x01\x90Pa'\xA8_\x83\x01\x84a'\x86V[\x92\x91PPV[a'\xB7\x81a%2V[\x81\x14a'\xC1W_\x80\xFD[PV[_\x815\x90Pa'\xD2\x81a'\xAEV[\x92\x91PPV[_\x80`@\x83\x85\x03\x12\x15a'\xEEWa'\xEDa#:V[[_a'\xFB\x85\x82\x86\x01a#\x88V[\x92PP` a(\x0C\x85\x82\x86\x01a'\xC4V[\x91PP\x92P\x92\x90PV[a(\x1F\x81a%2V[\x82RPPV[_` \x82\x01\x90Pa(8_\x83\x01\x84a(\x16V[\x92\x91PPV[_\x80`@\x83\x85\x03\x12\x15a(TWa(Sa#:V[[_a(a\x85\x82\x86\x01a#\x88V[\x92PP` a(r\x85\x82\x86\x01a#\xBBV[\x91PP\x92P\x92\x90PV[_` \x82\x84\x03\x12\x15a(\x91Wa(\x90a#:V[[_a(\x9E\x84\x82\x85\x01a%\xD8V[\x91PP\x92\x91PPV[_\x80_\x80`\x80\x85\x87\x03\x12\x15a(\xBFWa(\xBEa#:V[[_a(\xCC\x87\x82\x88\x01a#\x88V[\x94PP` a(\xDD\x87\x82\x88\x01a#\x88V[\x93PP`@a(\xEE\x87\x82\x88\x01a#\x88V[\x92PP``a(\xFF\x87\x82\x88\x01a#\xBBV[\x91PP\x92\x95\x91\x94P\x92PV[_\x80\xFD[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`A`\x04R`$_\xFD[a)E\x82a$\xEAV[\x81\x01\x81\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17\x15a)dWa)ca)\x0FV[[\x80`@RPPPV[_a)va#1V[\x90Pa)\x82\x82\x82a)<V[\x91\x90PV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15a)\xA1Wa)\xA0a)\x0FV[[a)\xAA\x82a$\xEAV[\x90P` \x81\x01\x90P\x91\x90PV[\x82\x81\x837_\x83\x83\x01RPPPV[_a)\xD7a)\xD2\x84a)\x87V[a)mV[\x90P\x82\x81R` \x81\x01\x84\x84\x84\x01\x11\x15a)\xF3Wa)\xF2a)\x0BV[[a)\xFE\x84\x82\x85a)\xB7V[P\x93\x92PPPV[_\x82`\x1F\x83\x01\x12a*\x1AWa*\x19a%\xECV[[\x815a**\x84\x82` \x86\x01a)\xC5V[\x91PP\x92\x91PPV[_\x80`@\x83\x85\x03\x12\x15a*IWa*Ha#:V[[_a*V\x85\x82\x86\x01a#\x88V[\x92PP` \x83\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a*wWa*va#>V[[a*\x83\x85\x82\x86\x01a*\x06V[\x91PP\x92P\x92\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_a*\xA7\x82a$\xA8V[a*\xB1\x81\x85a*\x8DV[\x93Pa*\xC1\x81\x85` \x86\x01a$\xC2V[a*\xCA\x81a$\xEAV[\x84\x01\x91PP\x92\x91PPV[_``\x82\x01\x90Pa*\xE8_\x83\x01\x86a'\x86V[\x81\x81\x03` \x83\x01Ra*\xFA\x81\x85a*\x9DV[\x90Pa+\t`@\x83\x01\x84a(\x16V[\x94\x93PPPPV[\x7FInternal only\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_a+E`\r\x83a*\x8DV[\x91Pa+P\x82a+\x11V[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra+r\x81a+9V[\x90P\x91\x90PV[_\x81Q\x90Pa+\x87\x81a#rV[\x92\x91PPV[_` \x82\x84\x03\x12\x15a+\xA2Wa+\xA1a#:V[[_a+\xAF\x84\x82\x85\x01a+yV[\x91PP\x92\x91PPV[\x7FUnauthorized tokens\0\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_a+\xEC`\x13\x83a*\x8DV[\x91Pa+\xF7\x82a+\xB8V[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra,\x19\x81a+\xE0V[\x90P\x91\x90PV[\x7FInvalid swap amounts\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_a,T`\x14\x83a*\x8DV[\x91Pa,_\x82a, V[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra,\x81\x81a,HV[\x90P\x91\x90PV[\x7FPrimary DEX not found\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_a,\xBC`\x15\x83a*\x8DV[\x91Pa,\xC7\x82a,\x88V[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra,\xE9\x81a,\xB0V[\x90P\x91\x90PV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x11`\x04R`$_\xFD[_a-'\x82a#\x9CV[\x91Pa-2\x83a#\x9CV[\x92P\x82\x82\x01\x90P\x80\x82\x11\x15a-JWa-Ia,\xF0V[[\x92\x91PPV[_\x81Q\x90Pa-^\x81a#\xA5V[\x92\x91PPV[_` \x82\x84\x03\x12\x15a-yWa-xa#:V[[_a-\x86\x84\x82\x85\x01a-PV[\x91PP\x92\x91PPV[\x7FNo balance for arbitrage\0\0\0\0\0\0\0\0_\x82\x01RPV[_a-\xC3`\x18\x83a*\x8DV[\x91Pa-\xCE\x82a-\x8FV[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra-\xF0\x81a-\xB7V[\x90P\x91\x90PV[_``\x82\x01\x90Pa.\n_\x83\x01\x86a'\x86V[a.\x17` \x83\x01\x85a$FV[a.$`@\x83\x01\x84a$FV[\x94\x93PPPPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\"`\x04R`$_\xFD[_`\x02\x82\x04\x90P`\x01\x82\x16\x80a.pW`\x7F\x82\x16\x91P[` \x82\x10\x81\x03a.\x83Wa.\x82a.,V[[P\x91\x90PV[_\x80_\x80`\x80\x85\x87\x03\x12\x15a.\xA1Wa.\xA0a#:V[[_a.\xAE\x87\x82\x88\x01a#\xBBV[\x94PP` a.\xBF\x87\x82\x88\x01a#\xBBV[\x93PP`@a.\xD0\x87\x82\x88\x01a#\xBBV[\x92PP``a.\xE1\x87\x82\x88\x01a#\xBBV[\x91PP\x92\x95\x91\x94P\x92PV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`2`\x04R`$_\xFD[_a/$\x82a#\x9CV[\x91Pa//\x83a#\x9CV[\x92P\x82\x82\x03\x90P\x81\x81\x11\x15a/GWa/Fa,\xF0V[[\x92\x91PPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`1`\x04R`$_\xFD[_a/\x84\x82a#\x9CV[\x91P\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x03a/\xB6Wa/\xB5a,\xF0V[[`\x01\x82\x01\x90P\x91\x90PV[_`@\x82\x01\x90Pa/\xD4_\x83\x01\x85a'\x86V[a/\xE1` \x83\x01\x84a$FV[\x93\x92PPPV[_\x81Q\x90Pa/\xF6\x81a'\xAEV[\x92\x91PPV[_` \x82\x84\x03\x12\x15a0\x11Wa0\x10a#:V[[_a0\x1E\x84\x82\x85\x01a/\xE8V[\x91PP\x92\x91PPV[_\x81Q\x90P\x91\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_\x81\x90P` \x82\x01\x90P\x91\x90PV[_a0[\x83\x83a$\x99V[` \x83\x01\x90P\x92\x91PPV[_` \x82\x01\x90P\x91\x90PV[_a0}\x82a0'V[a0\x87\x81\x85a01V[\x93Pa0\x92\x83a0AV[\x80_[\x83\x81\x10\x15a0\xC2W\x81Qa0\xA9\x88\x82a0PV[\x97Pa0\xB4\x83a0gV[\x92PP`\x01\x81\x01\x90Pa0\x95V[P\x85\x93PPPP\x92\x91PPV[_`@\x82\x01\x90Pa0\xE2_\x83\x01\x85a$FV[\x81\x81\x03` \x83\x01Ra0\xF4\x81\x84a0sV[\x90P\x93\x92PPPV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15a1\x17Wa1\x16a)\x0FV[[` \x82\x02\x90P` \x81\x01\x90P\x91\x90PV[_a1:a15\x84a0\xFDV[a)mV[\x90P\x80\x83\x82R` \x82\x01\x90P` \x84\x02\x83\x01\x85\x81\x11\x15a1]Wa1\\a%\xF4V[[\x83[\x81\x81\x10\x15a1\x86W\x80a1r\x88\x82a-PV[\x84R` \x84\x01\x93PP` \x81\x01\x90Pa1_V[PPP\x93\x92PPPV[_\x82`\x1F\x83\x01\x12a1\xA4Wa1\xA3a%\xECV[[\x81Qa1\xB4\x84\x82` \x86\x01a1(V[\x91PP\x92\x91PPV[_` \x82\x84\x03\x12\x15a1\xD2Wa1\xD1a#:V[[_\x82\x01Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a1\xEFWa1\xEEa#>V[[a1\xFB\x84\x82\x85\x01a1\x90V[\x91PP\x92\x91PPV[_\x81\x90P\x81_R` _ \x90P\x91\x90PV[_` `\x1F\x83\x01\x04\x90P\x91\x90PV[_\x82\x82\x1B\x90P\x92\x91PPV[_`\x08\x83\x02a2`\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82a2%V[a2j\x86\x83a2%V[\x95P\x80\x19\x84\x16\x93P\x80\x86\x16\x84\x17\x92PPP\x93\x92PPPV[_\x81\x90P\x91\x90PV[_a2\xA5a2\xA0a2\x9B\x84a#\x9CV[a2\x82V[a#\x9CV[\x90P\x91\x90PV[_\x81\x90P\x91\x90PV[a2\xBE\x83a2\x8BV[a2\xD2a2\xCA\x82a2\xACV[\x84\x84Ta21V[\x82UPPPPV[_\x90V[a2\xE6a2\xDAV[a2\xF1\x81\x84\x84a2\xB5V[PPPV[[\x81\x81\x10\x15a3\x14Wa3\t_\x82a2\xDEV[`\x01\x81\x01\x90Pa2\xF7V[PPV[`\x1F\x82\x11\x15a3YWa3*\x81a2\x04V[a33\x84a2\x16V[\x81\x01` \x85\x10\x15a3BW\x81\x90P[a3Va3N\x85a2\x16V[\x83\x01\x82a2\xF6V[PP[PPPV[_\x82\x82\x1C\x90P\x92\x91PPV[_a3y_\x19\x84`\x08\x02a3^V[\x19\x80\x83\x16\x91PP\x92\x91PPV[_a3\x91\x83\x83a3jV[\x91P\x82`\x02\x02\x82\x17\x90P\x92\x91PPV[a3\xAA\x82a$\xA8V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a3\xC3Wa3\xC2a)\x0FV[[a3\xCD\x82Ta.YV[a3\xD8\x82\x82\x85a3\x18V[_` \x90P`\x1F\x83\x11`\x01\x81\x14a4\tW_\x84\x15a3\xF7W\x82\x87\x01Q\x90P[a4\x01\x85\x82a3\x86V[\x86UPa4hV[`\x1F\x19\x84\x16a4\x17\x86a2\x04V[_[\x82\x81\x10\x15a4>W\x84\x89\x01Q\x82U`\x01\x82\x01\x91P` \x85\x01\x94P` \x81\x01\x90Pa4\x19V[\x86\x83\x10\x15a4[W\x84\x89\x01Qa4W`\x1F\x89\x16\x82a3jV[\x83UP[`\x01`\x02\x88\x02\x01\x88UPPP[PPPPPPV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra4\x88\x81\x84a*\x9DV[\x90P\x92\x91PPV[_`\x80\x82\x01\x90Pa4\xA3_\x83\x01\x87a'\x86V[a4\xB0` \x83\x01\x86a'\x86V[a4\xBD`@\x83\x01\x85a'\x86V[a4\xCA``\x83\x01\x84a$FV[\x95\x94PPPPPV[_`\xA0\x82\x01\x90Pa4\xE6_\x83\x01\x88a$FV[a4\xF3` \x83\x01\x87a$FV[\x81\x81\x03`@\x83\x01Ra5\x05\x81\x86a0sV[\x90Pa5\x14``\x83\x01\x85a'\x86V[a5!`\x80\x83\x01\x84a$FV[\x96\x95PPPPPPV[_`\xA0\x82\x01\x90Pa5>_\x83\x01\x88a'\x86V[a5K` \x83\x01\x87a$FV[a5X`@\x83\x01\x86a$FV[a5e``\x83\x01\x85a$FV[a5r`\x80\x83\x01\x84a$FV[\x96\x95PPPPPPV[_\x81`\xE0\x1C\x90P\x91\x90PV[_`\x03=\x11\x15a5\xA4W`\x04_\x80>a5\xA1_Qa5|V[\x90P[\x90V[_`D=\x10a63Wa5\xB8a#1V[`\x04=\x03`\x04\x82>\x80Q=`$\x82\x01\x11g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17\x15a5\xE0WPPa63V[\x80\x82\x01\x80Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a5\xFEWPPPPa63V[\x80` \x83\x01\x01`\x04=\x03\x85\x01\x81\x11\x15a6\x1BWPPPPPa63V[a6*\x82` \x01\x85\x01\x86a)<V[\x82\x95PPPPPP[\x90V[\x7FUnknown error\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_a6j`\r\x83a*\x8DV[\x91Pa6u\x82a66V[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra6\x97\x81a6^V[\x90P\x91\x90PV[_`@\x82\x01\x90Pa6\xB1_\x83\x01\x85a'\x86V[a6\xBE` \x83\x01\x84a'\x86V[\x93\x92PPPV\xFE\xA2dipfsX\"\x12 LZV\x88\x851\x07hU\xDB#\x13\xD6\xED\x0E\xCC\x88}_+\xBE\"\xB4\xDE)X\xF3\x8F3\xB2m\xD9dsolcC\0\x08\x14\x003",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x60806040526004361061019f575f3560e01c8063898622e8116100eb578063b663bce411610089578063dcbe43d911610063578063dcbe43d9146105b4578063e7c2269e146105dc578063f14210a61461061a578063f2fde38b14610642576101a6565b8063b663bce414610526578063c028646514610562578063d6b2ab241461058a576101a6565b80639bc7c586116100c55780639bc7c5861461044a5780639e281a9814610486578063ac3c34b8146104ae578063adb7092a146104ea576101a6565b8063898622e8146103ce5780638c8f3f82146103f85780638da5cb5b14610420576101a6565b80634b3f3378116101585780635c1bba38116101325780635c1bba381461033c578063715018a6146103665780637341ab8c1461037c57806382cc696d146103a6576101a6565b80634b3f3378146102b05780634caf81f5146102d857806353fc838b14610314576101a6565b8063095bf923146101aa57806310fa79e2146101d2578063161efb62146101fc5780632547fa3e146102385780633ea6f207146102605780633f8a346714610288576101a6565b366101a657005b5f80fd5b3480156101b5575f80fd5b506101d060048036038101906101cb91906123cf565b61066a565b005b3480156101dd575f80fd5b506101e6610b81565b6040516101f39190612455565b60405180910390f35b348015610207575f80fd5b50610222600480360381019061021d919061246e565b610b87565b60405161022f9190612599565b60405180910390f35b348015610243575f80fd5b5061025e6004803603810190610259919061246e565b610cdc565b005b34801561026b575f80fd5b506102866004803603810190610281919061264d565b610d27565b005b348015610293575f80fd5b506102ae60048036038101906102a991906126f7565b610e2e565b005b3480156102bb575f80fd5b506102d660048036038101906102d1919061275b565b610f14565b005b3480156102e3575f80fd5b506102fe60048036038101906102f9919061275b565b610f26565b60405161030b9190612795565b60405180910390f35b34801561031f575f80fd5b5061033a600480360381019061033591906127d8565b610f61565b005b348015610347575f80fd5b50610350610fc1565b60405161035d9190612795565b60405180910390f35b348015610371575f80fd5b5061037a610fe6565b005b348015610387575f80fd5b50610390610ff9565b60405161039d9190612455565b60405180910390f35b3480156103b1575f80fd5b506103cc60048036038101906103c7919061275b565b610fff565b005b3480156103d9575f80fd5b506103e2611011565b6040516103ef9190612455565b60405180910390f35b348015610403575f80fd5b5061041e6004803603810190610419919061246e565b611017565b005b34801561042b575f80fd5b5061043461123c565b6040516104419190612795565b60405180910390f35b348015610455575f80fd5b50610470600480360381019061046b919061246e565b611263565b60405161047d9190612825565b60405180910390f35b348015610491575f80fd5b506104ac60048036038101906104a7919061283e565b611280565b005b3480156104b9575f80fd5b506104d460048036038101906104cf919061246e565b61130f565b6040516104e19190612795565b60405180910390f35b3480156104f5575f80fd5b50610510600480360381019061050b919061287c565b61133f565b60405161051d9190612795565b60405180910390f35b348015610531575f80fd5b5061054c600480360381019061054791906128a7565b61136f565b6040516105599190612455565b60405180910390f35b34801561056d575f80fd5b506105886004803603810190610583919061275b565b611570565b005b348015610595575f80fd5b5061059e611582565b6040516105ab9190612455565b60405180910390f35b3480156105bf575f80fd5b506105da60048036038101906105d59190612a33565b61158e565b005b3480156105e7575f80fd5b5061060260048036038101906105fd919061246e565b6117fa565b60405161061193929190612ad5565b60405180910390f35b348015610625575f80fd5b50610640600480360381019061063b919061275b565b6118d1565b005b34801561064d575f80fd5b506106686004803603810190610663919061246e565b611927565b005b6106726119ab565b3073ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16146106e0576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016106d790612b5b565b60405180910390fd5b5f8590505f8173ffffffffffffffffffffffffffffffffffffffff16630dfe16816040518163ffffffff1660e01b8152600401602060405180830381865afa15801561072e573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906107529190612b8d565b90505f8273ffffffffffffffffffffffffffffffffffffffff1663d21220a76040518163ffffffff1660e01b8152600401602060405180830381865afa15801561079e573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906107c29190612b8d565b905060085f8373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f9054906101000a900460ff161580610861575060085f8273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f9054906101000a900460ff16155b156108a1576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161089890612c02565b60405180910390fd5b5f805f808a1180156108b257505f87115b156108c557849250839150899050610922565b5f891180156108d357505f88115b156108e657839250849150889050610921565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161091890612c6a565b60405180910390fd5b5b6006548111156109325760065490505b5f61093c8c6119f1565b90505f73ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff16036109ac576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016109a390612cd2565b60405180910390fd5b5f805f6109bb86888787611be4565b9250925092506007546005546109d19190612d1d565b811015610a0a576040517f4e47f8ea00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f8673ffffffffffffffffffffffffffffffffffffffff166370a08231306040518263ffffffff1660e01b8152600401610a449190612795565b602060405180830381865afa158015610a5f573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610a839190612d64565b90505f8103610ac7576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610abe90612dd9565b60405180910390fd5b5f868210610ad55786610ad7565b815b9050610ae685898b8488611d99565b8773ffffffffffffffffffffffffffffffffffffffff168573ffffffffffffffffffffffffffffffffffffffff168773ffffffffffffffffffffffffffffffffffffffff167f9fdefc319d5b857fa8ec2d985b19e06aa8e5b47517c20119b640ef7eb642d00d8c8588604051610b5e93929190612df7565b60405180910390a4505050505050505050505050610b7a611fca565b5050505050565b60065481565b610b8f6122fa565b60035f8373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f206040518060600160405290815f82015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001600182018054610c3b90612e59565b80601f0160208091040260200160405190810160405280929190818152602001828054610c6790612e59565b8015610cb25780601f10610c8957610100808354040283529160200191610cb2565b820191905f5260205f20905b815481529060010190602001808311610c9557829003601f168201915b50505050508152602001600282015f9054906101000a900460ff1615151515815250509050919050565b610ce4611fd3565b8060025f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555050565b60025f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614610dad576040517f5c427cd900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f855f1c90505f855f1c90506080848490501015610df7576040517fac66c1e900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f805f808787810190610e0a9190612e89565b9350935093509350610e1f8d8585858561205a565b50505050505050505050505050565b610e36611fd3565b5f610e41858561219e565b90508260095f8381526020019081526020015f205f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555081600a5f8573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055505050505050565b610f1c611fd3565b8060068190555050565b60048181548110610f35575f80fd5b905f5260205f20015f915054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b610f69611fd3565b8060085f8473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f6101000a81548160ff0219169083151502179055505050565b60025f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b610fee611fd3565b610ff75f612232565b565b60055481565b611007611fd3565b8060078190555050565b60075481565b61101f611fd3565b5f60035f8373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f206002015f6101000a81548160ff0219169083151502179055505f5b6004805490508110156111f5578173ffffffffffffffffffffffffffffffffffffffff16600482815481106110b0576110af612eed565b5b905f5260205f20015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16036111e257600460016004805490506111079190612f1a565b8154811061111857611117612eed565b5b905f5260205f20015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff166004828154811061115457611153612eed565b5b905f5260205f20015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555060048054806111ab576111aa612f4d565b5b600190038181905f5260205f20015f6101000a81549073ffffffffffffffffffffffffffffffffffffffff021916905590556111f5565b80806111ed90612f7a565b915050611078565b508073ffffffffffffffffffffffffffffffffffffffff167f1921ba6698157d491d41801286e9e17aee1c25965119e55403ba396b104b95db60405160405180910390a250565b5f805f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b6008602052805f5260405f205f915054906101000a900460ff1681565b611288611fd3565b8173ffffffffffffffffffffffffffffffffffffffff1663a9059cbb6112ac61123c565b836040518363ffffffff1660e01b81526004016112ca929190612fc1565b6020604051808303815f875af11580156112e6573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061130a9190612ffc565b505050565b600a602052805f5260405f205f915054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b6009602052805f5260405f205f915054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b5f3073ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16146113de576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016113d590612b5b565b60405180910390fd5b5f600267ffffffffffffffff8111156113fa576113f961290f565b5b6040519080825280602002602001820160405280156114285781602001602082028036833780820191505090505b50905084815f8151811061143f5761143e612eed565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff1681525050838160018151811061148e5761148d612eed565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff16815250505f8673ffffffffffffffffffffffffffffffffffffffff1663d06ca61f85846040518363ffffffff1660e01b81526004016115049291906130cf565b5f60405180830381865afa15801561151e573d5f803e3d5ffd5b505050506040513d5f823e3d601f19601f8201168201806040525081019061154691906131bd565b90508060018151811061155c5761155b612eed565b5b602002602001015192505050949350505050565b611578611fd3565b8060058190555050565b5f600480549050905090565b611596611fd3565b5f73ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff1614806115d057505f8151145b15611607576040517fb62d9bd800000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f60035f8473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f20600101805461165390612e59565b9050036116bb57600482908060018154018082558091505060019003905f5260205f20015f9091909190916101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055505b60405180606001604052808373ffffffffffffffffffffffffffffffffffffffff1681526020018281526020016001151581525060035f8473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f820151815f015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550602082015181600101908161178591906133a1565b506040820151816002015f6101000a81548160ff0219169083151502179055509050508173ffffffffffffffffffffffffffffffffffffffff167fc4050e82e850253f4929bdbcd143eef487be2fad64739a4f3859e5143745b832826040516117ee9190613470565b60405180910390a25050565b6003602052805f5260405f205f91509050805f015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff169080600101805461183e90612e59565b80601f016020809104026020016040519081016040528092919081815260200182805461186a90612e59565b80156118b55780601f1061188c576101008083540402835291602001916118b5565b820191905f5260205f20905b81548152906001019060200180831161189857829003601f168201915b505050505090806002015f9054906101000a900460ff16905083565b6118d9611fd3565b6118e161123c565b73ffffffffffffffffffffffffffffffffffffffff166108fc8290811502906040515f60405180830381858888f19350505050158015611923573d5f803e3d5ffd5b5050565b61192f611fd3565b5f73ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff160361199f575f6040517f1e4fbdf70000000000000000000000000000000000000000000000000000000081526004016119969190612795565b60405180910390fd5b6119a881612232565b50565b6002600154036119e7576040517f3ee5aeb500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6002600181905550565b5f80600a5f8473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1690505f73ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1614158015611ad7575060035f8273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f206002015f9054906101000a900460ff165b15611ae55780915050611bdf565b5f5b600480549050811015611bd95760035f60048381548110611b0b57611b0a612eed565b5b905f5260205f20015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f206002015f9054906101000a900460ff1615611bc65760048181548110611b9557611b94612eed565b5b905f5260205f20015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1692505050611bdf565b8080611bd190612f7a565b915050611ae7565b505f9150505b919050565b5f805f8091505f92505f90505f5b600480549050811015611d8e575f60048281548110611c1457611c13612eed565b5b905f5260205f20015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905060035f8273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f206002015f9054906101000a900460ff161580611cc257508573ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff16145b15611ccd5750611d7b565b3073ffffffffffffffffffffffffffffffffffffffff1663b663bce4828b8b8b6040518563ffffffff1660e01b8152600401611d0c9493929190613490565b602060405180830381865afa925050508015611d4657506040513d601f19601f82011682018060405250810190611d439190612d64565b60015b611d505750611d7b565b8481118015611d5e57508781115b15611d78578094508195508781611d759190612f1a565b93505b50505b8080611d8690612f7a565b915050611bf2565b509450945094915050565b8373ffffffffffffffffffffffffffffffffffffffff1663095ea7b386846040518363ffffffff1660e01b8152600401611dd4929190612fc1565b6020604051808303815f875af1158015611df0573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190611e149190612ffc565b505f600267ffffffffffffffff811115611e3157611e3061290f565b5b604051908082528060200260200182016040528015611e5f5781602001602082028036833780820191505090505b50905084815f81518110611e7657611e75612eed565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff16815250508381600181518110611ec557611ec4612eed565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff16815250508573ffffffffffffffffffffffffffffffffffffffff166338ed17398484843061012c42611f2d9190612d1d565b6040518663ffffffff1660e01b8152600401611f4d9594939291906134d3565b5f604051808303815f875af1925050508015611f8b57506040513d5f823e3d601f19601f82011682018060405250810190611f8891906131bd565b60015b611fc1576040517fce074e5700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b50505050505050565b60018081905550565b611fdb6122f3565b73ffffffffffffffffffffffffffffffffffffffff16611ff961123c565b73ffffffffffffffffffffffffffffffffffffffff16146120585761201c6122f3565b6040517f118cdaa700000000000000000000000000000000000000000000000000000000815260040161204f9190612795565b60405180910390fd5b565b3073ffffffffffffffffffffffffffffffffffffffff1663095bf92386868686866040518663ffffffff1660e01b815260040161209b95949392919061352b565b5f604051808303815f87803b1580156120b2575f80fd5b505af19250505080156120c3575060015b612196576120cf613588565b806308c379a00361214257506120e36135a7565b806120ee5750612144565b8573ffffffffffffffffffffffffffffffffffffffff167f1eb7e96e616d0030b650f858d8263ccaf2db088e29a04f016f8eaf9a652f6d2c826040516121349190613470565b60405180910390a250612191565b505b8473ffffffffffffffffffffffffffffffffffffffff167f1eb7e96e616d0030b650f858d8263ccaf2db088e29a04f016f8eaf9a652f6d2c60405161218890613680565b60405180910390a25b612197565b5b5050505050565b5f8173ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff16106122005781836040516020016121e592919061369e565b6040516020818303038152906040528051906020012061222a565b828260405160200161221392919061369e565b604051602081830303815290604052805190602001205b905092915050565b5f805f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050815f806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508173ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a35050565b5f33905090565b60405180606001604052805f73ffffffffffffffffffffffffffffffffffffffff168152602001606081526020015f151581525090565b5f604051905090565b5f80fd5b5f80fd5b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f61236b82612342565b9050919050565b61237b81612361565b8114612385575f80fd5b50565b5f8135905061239681612372565b92915050565b5f819050919050565b6123ae8161239c565b81146123b8575f80fd5b50565b5f813590506123c9816123a5565b92915050565b5f805f805f60a086880312156123e8576123e761233a565b5b5f6123f588828901612388565b9550506020612406888289016123bb565b9450506040612417888289016123bb565b9350506060612428888289016123bb565b9250506080612439888289016123bb565b9150509295509295909350565b61244f8161239c565b82525050565b5f6020820190506124685f830184612446565b92915050565b5f602082840312156124835761248261233a565b5b5f61249084828501612388565b91505092915050565b6124a281612361565b82525050565b5f81519050919050565b5f82825260208201905092915050565b5f5b838110156124df5780820151818401526020810190506124c4565b5f8484015250505050565b5f601f19601f8301169050919050565b5f612504826124a8565b61250e81856124b2565b935061251e8185602086016124c2565b612527816124ea565b840191505092915050565b5f8115159050919050565b61254681612532565b82525050565b5f606083015f8301516125615f860182612499565b506020830151848203602086015261257982826124fa565b915050604083015161258e604086018261253d565b508091505092915050565b5f6020820190508181035f8301526125b1818461254c565b905092915050565b5f819050919050565b6125cb816125b9565b81146125d5575f80fd5b50565b5f813590506125e6816125c2565b92915050565b5f80fd5b5f80fd5b5f80fd5b5f8083601f84011261260d5761260c6125ec565b5b8235905067ffffffffffffffff81111561262a576126296125f0565b5b602083019150836001820283011115612646576126456125f4565b5b9250929050565b5f805f805f805f60c0888a0312156126685761266761233a565b5b5f6126758a828b01612388565b97505060206126868a828b016125d8565b96505060406126978a828b016125d8565b95505060606126a88a828b016125d8565b94505060806126b98a828b016125d8565b93505060a088013567ffffffffffffffff8111156126da576126d961233e565b5b6126e68a828b016125f8565b925092505092959891949750929550565b5f805f806080858703121561270f5761270e61233a565b5b5f61271c87828801612388565b945050602061272d87828801612388565b935050604061273e87828801612388565b925050606061274f87828801612388565b91505092959194509250565b5f602082840312156127705761276f61233a565b5b5f61277d848285016123bb565b91505092915050565b61278f81612361565b82525050565b5f6020820190506127a85f830184612786565b92915050565b6127b781612532565b81146127c1575f80fd5b50565b5f813590506127d2816127ae565b92915050565b5f80604083850312156127ee576127ed61233a565b5b5f6127fb85828601612388565b925050602061280c858286016127c4565b9150509250929050565b61281f81612532565b82525050565b5f6020820190506128385f830184612816565b92915050565b5f80604083850312156128545761285361233a565b5b5f61286185828601612388565b9250506020612872858286016123bb565b9150509250929050565b5f602082840312156128915761289061233a565b5b5f61289e848285016125d8565b91505092915050565b5f805f80608085870312156128bf576128be61233a565b5b5f6128cc87828801612388565b94505060206128dd87828801612388565b93505060406128ee87828801612388565b92505060606128ff878288016123bb565b91505092959194509250565b5f80fd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b612945826124ea565b810181811067ffffffffffffffff821117156129645761296361290f565b5b80604052505050565b5f612976612331565b9050612982828261293c565b919050565b5f67ffffffffffffffff8211156129a1576129a061290f565b5b6129aa826124ea565b9050602081019050919050565b828183375f83830152505050565b5f6129d76129d284612987565b61296d565b9050828152602081018484840111156129f3576129f261290b565b5b6129fe8482856129b7565b509392505050565b5f82601f830112612a1a57612a196125ec565b5b8135612a2a8482602086016129c5565b91505092915050565b5f8060408385031215612a4957612a4861233a565b5b5f612a5685828601612388565b925050602083013567ffffffffffffffff811115612a7757612a7661233e565b5b612a8385828601612a06565b9150509250929050565b5f82825260208201905092915050565b5f612aa7826124a8565b612ab18185612a8d565b9350612ac18185602086016124c2565b612aca816124ea565b840191505092915050565b5f606082019050612ae85f830186612786565b8181036020830152612afa8185612a9d565b9050612b096040830184612816565b949350505050565b7f496e7465726e616c206f6e6c79000000000000000000000000000000000000005f82015250565b5f612b45600d83612a8d565b9150612b5082612b11565b602082019050919050565b5f6020820190508181035f830152612b7281612b39565b9050919050565b5f81519050612b8781612372565b92915050565b5f60208284031215612ba257612ba161233a565b5b5f612baf84828501612b79565b91505092915050565b7f556e617574686f72697a656420746f6b656e73000000000000000000000000005f82015250565b5f612bec601383612a8d565b9150612bf782612bb8565b602082019050919050565b5f6020820190508181035f830152612c1981612be0565b9050919050565b7f496e76616c6964207377617020616d6f756e74730000000000000000000000005f82015250565b5f612c54601483612a8d565b9150612c5f82612c20565b602082019050919050565b5f6020820190508181035f830152612c8181612c48565b9050919050565b7f5072696d61727920444558206e6f7420666f756e6400000000000000000000005f82015250565b5f612cbc601583612a8d565b9150612cc782612c88565b602082019050919050565b5f6020820190508181035f830152612ce981612cb0565b9050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f612d278261239c565b9150612d328361239c565b9250828201905080821115612d4a57612d49612cf0565b5b92915050565b5f81519050612d5e816123a5565b92915050565b5f60208284031215612d7957612d7861233a565b5b5f612d8684828501612d50565b91505092915050565b7f4e6f2062616c616e636520666f722061726269747261676500000000000000005f82015250565b5f612dc3601883612a8d565b9150612dce82612d8f565b602082019050919050565b5f6020820190508181035f830152612df081612db7565b9050919050565b5f606082019050612e0a5f830186612786565b612e176020830185612446565b612e246040830184612446565b949350505050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602260045260245ffd5b5f6002820490506001821680612e7057607f821691505b602082108103612e8357612e82612e2c565b5b50919050565b5f805f8060808587031215612ea157612ea061233a565b5b5f612eae878288016123bb565b9450506020612ebf878288016123bb565b9350506040612ed0878288016123bb565b9250506060612ee1878288016123bb565b91505092959194509250565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b5f612f248261239c565b9150612f2f8361239c565b9250828203905081811115612f4757612f46612cf0565b5b92915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603160045260245ffd5b5f612f848261239c565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203612fb657612fb5612cf0565b5b600182019050919050565b5f604082019050612fd45f830185612786565b612fe16020830184612446565b9392505050565b5f81519050612ff6816127ae565b92915050565b5f602082840312156130115761301061233a565b5b5f61301e84828501612fe8565b91505092915050565b5f81519050919050565b5f82825260208201905092915050565b5f819050602082019050919050565b5f61305b8383612499565b60208301905092915050565b5f602082019050919050565b5f61307d82613027565b6130878185613031565b935061309283613041565b805f5b838110156130c25781516130a98882613050565b97506130b483613067565b925050600181019050613095565b5085935050505092915050565b5f6040820190506130e25f830185612446565b81810360208301526130f48184613073565b90509392505050565b5f67ffffffffffffffff8211156131175761311661290f565b5b602082029050602081019050919050565b5f61313a613135846130fd565b61296d565b9050808382526020820190506020840283018581111561315d5761315c6125f4565b5b835b8181101561318657806131728882612d50565b84526020840193505060208101905061315f565b5050509392505050565b5f82601f8301126131a4576131a36125ec565b5b81516131b4848260208601613128565b91505092915050565b5f602082840312156131d2576131d161233a565b5b5f82015167ffffffffffffffff8111156131ef576131ee61233e565b5b6131fb84828501613190565b91505092915050565b5f819050815f5260205f209050919050565b5f6020601f8301049050919050565b5f82821b905092915050565b5f600883026132607fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82613225565b61326a8683613225565b95508019841693508086168417925050509392505050565b5f819050919050565b5f6132a56132a061329b8461239c565b613282565b61239c565b9050919050565b5f819050919050565b6132be8361328b565b6132d26132ca826132ac565b848454613231565b825550505050565b5f90565b6132e66132da565b6132f18184846132b5565b505050565b5b81811015613314576133095f826132de565b6001810190506132f7565b5050565b601f8211156133595761332a81613204565b61333384613216565b81016020851015613342578190505b61335661334e85613216565b8301826132f6565b50505b505050565b5f82821c905092915050565b5f6133795f198460080261335e565b1980831691505092915050565b5f613391838361336a565b9150826002028217905092915050565b6133aa826124a8565b67ffffffffffffffff8111156133c3576133c261290f565b5b6133cd8254612e59565b6133d8828285613318565b5f60209050601f831160018114613409575f84156133f7578287015190505b6134018582613386565b865550613468565b601f19841661341786613204565b5f5b8281101561343e57848901518255600182019150602085019450602081019050613419565b8683101561345b5784890151613457601f89168261336a565b8355505b6001600288020188555050505b505050505050565b5f6020820190508181035f8301526134888184612a9d565b905092915050565b5f6080820190506134a35f830187612786565b6134b06020830186612786565b6134bd6040830185612786565b6134ca6060830184612446565b95945050505050565b5f60a0820190506134e65f830188612446565b6134f36020830187612446565b81810360408301526135058186613073565b90506135146060830185612786565b6135216080830184612446565b9695505050505050565b5f60a08201905061353e5f830188612786565b61354b6020830187612446565b6135586040830186612446565b6135656060830185612446565b6135726080830184612446565b9695505050505050565b5f8160e01c9050919050565b5f60033d11156135a45760045f803e6135a15f5161357c565b90505b90565b5f60443d10613633576135b8612331565b60043d036004823e80513d602482011167ffffffffffffffff821117156135e0575050613633565b808201805167ffffffffffffffff8111156135fe5750505050613633565b80602083010160043d03850181111561361b575050505050613633565b61362a8260200185018661293c565b82955050505050505b90565b7f556e6b6e6f776e206572726f72000000000000000000000000000000000000005f82015250565b5f61366a600d83612a8d565b915061367582613636565b602082019050919050565b5f6020820190508181035f8301526136978161365e565b9050919050565b5f6040820190506136b15f830185612786565b6136be6020830184612786565b939250505056fea26469706673582212204c5a56888531076855db2313d6ed0ecc887d5f2bbe22b4de2958f38f33b26dd964736f6c63430008140033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R`\x046\x10a\x01\x9FW_5`\xE0\x1C\x80c\x89\x86\"\xE8\x11a\0\xEBW\x80c\xB6c\xBC\xE4\x11a\0\x89W\x80c\xDC\xBEC\xD9\x11a\0cW\x80c\xDC\xBEC\xD9\x14a\x05\xB4W\x80c\xE7\xC2&\x9E\x14a\x05\xDCW\x80c\xF1B\x10\xA6\x14a\x06\x1AW\x80c\xF2\xFD\xE3\x8B\x14a\x06BWa\x01\xA6V[\x80c\xB6c\xBC\xE4\x14a\x05&W\x80c\xC0(de\x14a\x05bW\x80c\xD6\xB2\xAB$\x14a\x05\x8AWa\x01\xA6V[\x80c\x9B\xC7\xC5\x86\x11a\0\xC5W\x80c\x9B\xC7\xC5\x86\x14a\x04JW\x80c\x9E(\x1A\x98\x14a\x04\x86W\x80c\xAC<4\xB8\x14a\x04\xAEW\x80c\xAD\xB7\t*\x14a\x04\xEAWa\x01\xA6V[\x80c\x89\x86\"\xE8\x14a\x03\xCEW\x80c\x8C\x8F?\x82\x14a\x03\xF8W\x80c\x8D\xA5\xCB[\x14a\x04 Wa\x01\xA6V[\x80cK?3x\x11a\x01XW\x80c\\\x1B\xBA8\x11a\x012W\x80c\\\x1B\xBA8\x14a\x03<W\x80cqP\x18\xA6\x14a\x03fW\x80csA\xAB\x8C\x14a\x03|W\x80c\x82\xCCim\x14a\x03\xA6Wa\x01\xA6V[\x80cK?3x\x14a\x02\xB0W\x80cL\xAF\x81\xF5\x14a\x02\xD8W\x80cS\xFC\x83\x8B\x14a\x03\x14Wa\x01\xA6V[\x80c\t[\xF9#\x14a\x01\xAAW\x80c\x10\xFAy\xE2\x14a\x01\xD2W\x80c\x16\x1E\xFBb\x14a\x01\xFCW\x80c%G\xFA>\x14a\x028W\x80c>\xA6\xF2\x07\x14a\x02`W\x80c?\x8A4g\x14a\x02\x88Wa\x01\xA6V[6a\x01\xA6W\0[_\x80\xFD[4\x80\x15a\x01\xB5W_\x80\xFD[Pa\x01\xD0`\x04\x806\x03\x81\x01\x90a\x01\xCB\x91\x90a#\xCFV[a\x06jV[\0[4\x80\x15a\x01\xDDW_\x80\xFD[Pa\x01\xE6a\x0B\x81V[`@Qa\x01\xF3\x91\x90a$UV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02\x07W_\x80\xFD[Pa\x02\"`\x04\x806\x03\x81\x01\x90a\x02\x1D\x91\x90a$nV[a\x0B\x87V[`@Qa\x02/\x91\x90a%\x99V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02CW_\x80\xFD[Pa\x02^`\x04\x806\x03\x81\x01\x90a\x02Y\x91\x90a$nV[a\x0C\xDCV[\0[4\x80\x15a\x02kW_\x80\xFD[Pa\x02\x86`\x04\x806\x03\x81\x01\x90a\x02\x81\x91\x90a&MV[a\r'V[\0[4\x80\x15a\x02\x93W_\x80\xFD[Pa\x02\xAE`\x04\x806\x03\x81\x01\x90a\x02\xA9\x91\x90a&\xF7V[a\x0E.V[\0[4\x80\x15a\x02\xBBW_\x80\xFD[Pa\x02\xD6`\x04\x806\x03\x81\x01\x90a\x02\xD1\x91\x90a'[V[a\x0F\x14V[\0[4\x80\x15a\x02\xE3W_\x80\xFD[Pa\x02\xFE`\x04\x806\x03\x81\x01\x90a\x02\xF9\x91\x90a'[V[a\x0F&V[`@Qa\x03\x0B\x91\x90a'\x95V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03\x1FW_\x80\xFD[Pa\x03:`\x04\x806\x03\x81\x01\x90a\x035\x91\x90a'\xD8V[a\x0FaV[\0[4\x80\x15a\x03GW_\x80\xFD[Pa\x03Pa\x0F\xC1V[`@Qa\x03]\x91\x90a'\x95V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03qW_\x80\xFD[Pa\x03za\x0F\xE6V[\0[4\x80\x15a\x03\x87W_\x80\xFD[Pa\x03\x90a\x0F\xF9V[`@Qa\x03\x9D\x91\x90a$UV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03\xB1W_\x80\xFD[Pa\x03\xCC`\x04\x806\x03\x81\x01\x90a\x03\xC7\x91\x90a'[V[a\x0F\xFFV[\0[4\x80\x15a\x03\xD9W_\x80\xFD[Pa\x03\xE2a\x10\x11V[`@Qa\x03\xEF\x91\x90a$UV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04\x03W_\x80\xFD[Pa\x04\x1E`\x04\x806\x03\x81\x01\x90a\x04\x19\x91\x90a$nV[a\x10\x17V[\0[4\x80\x15a\x04+W_\x80\xFD[Pa\x044a\x12<V[`@Qa\x04A\x91\x90a'\x95V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04UW_\x80\xFD[Pa\x04p`\x04\x806\x03\x81\x01\x90a\x04k\x91\x90a$nV[a\x12cV[`@Qa\x04}\x91\x90a(%V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04\x91W_\x80\xFD[Pa\x04\xAC`\x04\x806\x03\x81\x01\x90a\x04\xA7\x91\x90a(>V[a\x12\x80V[\0[4\x80\x15a\x04\xB9W_\x80\xFD[Pa\x04\xD4`\x04\x806\x03\x81\x01\x90a\x04\xCF\x91\x90a$nV[a\x13\x0FV[`@Qa\x04\xE1\x91\x90a'\x95V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04\xF5W_\x80\xFD[Pa\x05\x10`\x04\x806\x03\x81\x01\x90a\x05\x0B\x91\x90a(|V[a\x13?V[`@Qa\x05\x1D\x91\x90a'\x95V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x051W_\x80\xFD[Pa\x05L`\x04\x806\x03\x81\x01\x90a\x05G\x91\x90a(\xA7V[a\x13oV[`@Qa\x05Y\x91\x90a$UV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x05mW_\x80\xFD[Pa\x05\x88`\x04\x806\x03\x81\x01\x90a\x05\x83\x91\x90a'[V[a\x15pV[\0[4\x80\x15a\x05\x95W_\x80\xFD[Pa\x05\x9Ea\x15\x82V[`@Qa\x05\xAB\x91\x90a$UV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x05\xBFW_\x80\xFD[Pa\x05\xDA`\x04\x806\x03\x81\x01\x90a\x05\xD5\x91\x90a*3V[a\x15\x8EV[\0[4\x80\x15a\x05\xE7W_\x80\xFD[Pa\x06\x02`\x04\x806\x03\x81\x01\x90a\x05\xFD\x91\x90a$nV[a\x17\xFAV[`@Qa\x06\x11\x93\x92\x91\x90a*\xD5V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x06%W_\x80\xFD[Pa\x06@`\x04\x806\x03\x81\x01\x90a\x06;\x91\x90a'[V[a\x18\xD1V[\0[4\x80\x15a\x06MW_\x80\xFD[Pa\x06h`\x04\x806\x03\x81\x01\x90a\x06c\x91\x90a$nV[a\x19'V[\0[a\x06ra\x19\xABV[0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x06\xE0W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x06\xD7\x90a+[V[`@Q\x80\x91\x03\x90\xFD[_\x85\x90P_\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\r\xFE\x16\x81`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x07.W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x07R\x91\x90a+\x8DV[\x90P_\x82s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xD2\x12 \xA7`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x07\x9EW=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x07\xC2\x91\x90a+\x8DV[\x90P`\x08_\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x15\x80a\x08aWP`\x08_\x82s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x15[\x15a\x08\xA1W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x08\x98\x90a,\x02V[`@Q\x80\x91\x03\x90\xFD[_\x80_\x80\x8A\x11\x80\x15a\x08\xB2WP_\x87\x11[\x15a\x08\xC5W\x84\x92P\x83\x91P\x89\x90Pa\t\"V[_\x89\x11\x80\x15a\x08\xD3WP_\x88\x11[\x15a\x08\xE6W\x83\x92P\x84\x91P\x88\x90Pa\t!V[`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\t\x18\x90a,jV[`@Q\x80\x91\x03\x90\xFD[[`\x06T\x81\x11\x15a\t2W`\x06T\x90P[_a\t<\x8Ca\x19\xF1V[\x90P_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x03a\t\xACW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\t\xA3\x90a,\xD2V[`@Q\x80\x91\x03\x90\xFD[_\x80_a\t\xBB\x86\x88\x87\x87a\x1B\xE4V[\x92P\x92P\x92P`\x07T`\x05Ta\t\xD1\x91\x90a-\x1DV[\x81\x10\x15a\n\nW`@Q\x7FNG\xF8\xEA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x86s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16cp\xA0\x8210`@Q\x82c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\nD\x91\x90a'\x95V[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\n_W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\n\x83\x91\x90a-dV[\x90P_\x81\x03a\n\xC7W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\n\xBE\x90a-\xD9V[`@Q\x80\x91\x03\x90\xFD[_\x86\x82\x10a\n\xD5W\x86a\n\xD7V[\x81[\x90Pa\n\xE6\x85\x89\x8B\x84\x88a\x1D\x99V[\x87s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x85s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x87s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\x9F\xDE\xFC1\x9D[\x85\x7F\xA8\xEC-\x98[\x19\xE0j\xA8\xE5\xB4u\x17\xC2\x01\x19\xB6@\xEF~\xB6B\xD0\r\x8C\x85\x88`@Qa\x0B^\x93\x92\x91\x90a-\xF7V[`@Q\x80\x91\x03\x90\xA4PPPPPPPPPPPPa\x0Bza\x1F\xCAV[PPPPPV[`\x06T\x81V[a\x0B\x8Fa\"\xFAV[`\x03_\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ `@Q\x80``\x01`@R\x90\x81_\x82\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01`\x01\x82\x01\x80Ta\x0C;\x90a.YV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x0Cg\x90a.YV[\x80\x15a\x0C\xB2W\x80`\x1F\x10a\x0C\x89Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x0C\xB2V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x0C\x95W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x02\x82\x01_\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x15\x15\x15\x15\x81RPP\x90P\x91\x90PV[a\x0C\xE4a\x1F\xD3V[\x80`\x02_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UPPV[`\x02_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\r\xADW`@Q\x7F\\B|\xD9\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x85_\x1C\x90P_\x85_\x1C\x90P`\x80\x84\x84\x90P\x10\x15a\r\xF7W`@Q\x7F\xACf\xC1\xE9\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x80_\x80\x87\x87\x81\x01\x90a\x0E\n\x91\x90a.\x89V[\x93P\x93P\x93P\x93Pa\x0E\x1F\x8D\x85\x85\x85\x85a ZV[PPPPPPPPPPPPPV[a\x0E6a\x1F\xD3V[_a\x0EA\x85\x85a!\x9EV[\x90P\x82`\t_\x83\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP\x81`\n_\x85s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UPPPPPPV[a\x0F\x1Ca\x1F\xD3V[\x80`\x06\x81\x90UPPV[`\x04\x81\x81T\x81\x10a\x0F5W_\x80\xFD[\x90_R` _ \x01_\x91PT\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81V[a\x0Fia\x1F\xD3V[\x80`\x08_\x84s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UPPPV[`\x02_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81V[a\x0F\xEEa\x1F\xD3V[a\x0F\xF7_a\"2V[V[`\x05T\x81V[a\x10\x07a\x1F\xD3V[\x80`\x07\x81\x90UPPV[`\x07T\x81V[a\x10\x1Fa\x1F\xD3V[_`\x03_\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ `\x02\x01_a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP_[`\x04\x80T\x90P\x81\x10\x15a\x11\xF5W\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`\x04\x82\x81T\x81\x10a\x10\xB0Wa\x10\xAFa.\xEDV[[\x90_R` _ \x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x03a\x11\xE2W`\x04`\x01`\x04\x80T\x90Pa\x11\x07\x91\x90a/\x1AV[\x81T\x81\x10a\x11\x18Wa\x11\x17a.\xEDV[[\x90_R` _ \x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`\x04\x82\x81T\x81\x10a\x11TWa\x11Sa.\xEDV[[\x90_R` _ \x01_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP`\x04\x80T\x80a\x11\xABWa\x11\xAAa/MV[[`\x01\x90\x03\x81\x81\x90_R` _ \x01_a\x01\0\n\x81T\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90U\x90Ua\x11\xF5V[\x80\x80a\x11\xED\x90a/zV[\x91PPa\x10xV[P\x80s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\x19!\xBAf\x98\x15}I\x1DA\x80\x12\x86\xE9\xE1z\xEE\x1C%\x96Q\x19\xE5T\x03\xBA9k\x10K\x95\xDB`@Q`@Q\x80\x91\x03\x90\xA2PV[_\x80_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x90V[`\x08` R\x80_R`@_ _\x91PT\x90a\x01\0\n\x90\x04`\xFF\x16\x81V[a\x12\x88a\x1F\xD3V[\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xA9\x05\x9C\xBBa\x12\xACa\x12<V[\x83`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x12\xCA\x92\x91\x90a/\xC1V[` `@Q\x80\x83\x03\x81_\x87Z\xF1\x15\x80\x15a\x12\xE6W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x13\n\x91\x90a/\xFCV[PPPV[`\n` R\x80_R`@_ _\x91PT\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81V[`\t` R\x80_R`@_ _\x91PT\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81V[_0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x13\xDEW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x13\xD5\x90a+[V[`@Q\x80\x91\x03\x90\xFD[_`\x02g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x13\xFAWa\x13\xF9a)\x0FV[[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\x14(W\x81` \x01` \x82\x02\x806\x837\x80\x82\x01\x91PP\x90P[P\x90P\x84\x81_\x81Q\x81\x10a\x14?Wa\x14>a.\xEDV[[` \x02` \x01\x01\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81RPP\x83\x81`\x01\x81Q\x81\x10a\x14\x8EWa\x14\x8Da.\xEDV[[` \x02` \x01\x01\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81RPP_\x86s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xD0l\xA6\x1F\x85\x84`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x15\x04\x92\x91\x90a0\xCFV[_`@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x15\x1EW=_\x80>=_\xFD[PPPP`@Q=_\x82>=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x15F\x91\x90a1\xBDV[\x90P\x80`\x01\x81Q\x81\x10a\x15\\Wa\x15[a.\xEDV[[` \x02` \x01\x01Q\x92PPP\x94\x93PPPPV[a\x15xa\x1F\xD3V[\x80`\x05\x81\x90UPPV[_`\x04\x80T\x90P\x90P\x90V[a\x15\x96a\x1F\xD3V[_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x82s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14\x80a\x15\xD0WP_\x81Q\x14[\x15a\x16\x07W`@Q\x7F\xB6-\x9B\xD8\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x03_\x84s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ `\x01\x01\x80Ta\x16S\x90a.YV[\x90P\x03a\x16\xBBW`\x04\x82\x90\x80`\x01\x81T\x01\x80\x82U\x80\x91PP`\x01\x90\x03\x90_R` _ \x01_\x90\x91\x90\x91\x90\x91a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP[`@Q\x80``\x01`@R\x80\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x82\x81R` \x01`\x01\x15\x15\x81RP`\x03_\x84s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _\x82\x01Q\x81_\x01_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP` \x82\x01Q\x81`\x01\x01\x90\x81a\x17\x85\x91\x90a3\xA1V[P`@\x82\x01Q\x81`\x02\x01_a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x90PP\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xC4\x05\x0E\x82\xE8P%?I)\xBD\xBC\xD1C\xEE\xF4\x87\xBE/\xADds\x9AO8Y\xE5\x147E\xB82\x82`@Qa\x17\xEE\x91\x90a4pV[`@Q\x80\x91\x03\x90\xA2PPV[`\x03` R\x80_R`@_ _\x91P\x90P\x80_\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90\x80`\x01\x01\x80Ta\x18>\x90a.YV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x18j\x90a.YV[\x80\x15a\x18\xB5W\x80`\x1F\x10a\x18\x8CWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x18\xB5V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x18\x98W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x90\x80`\x02\x01_\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x90P\x83V[a\x18\xD9a\x1F\xD3V[a\x18\xE1a\x12<V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x08\xFC\x82\x90\x81\x15\x02\x90`@Q_`@Q\x80\x83\x03\x81\x85\x88\x88\xF1\x93PPPP\x15\x80\x15a\x19#W=_\x80>=_\xFD[PPV[a\x19/a\x1F\xD3V[_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x03a\x19\x9FW_`@Q\x7F\x1EO\xBD\xF7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x19\x96\x91\x90a'\x95V[`@Q\x80\x91\x03\x90\xFD[a\x19\xA8\x81a\"2V[PV[`\x02`\x01T\x03a\x19\xE7W`@Q\x7F>\xE5\xAE\xB5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x02`\x01\x81\x90UPV[_\x80`\n_\x84s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14\x15\x80\x15a\x1A\xD7WP`\x03_\x82s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ `\x02\x01_\x90T\x90a\x01\0\n\x90\x04`\xFF\x16[\x15a\x1A\xE5W\x80\x91PPa\x1B\xDFV[_[`\x04\x80T\x90P\x81\x10\x15a\x1B\xD9W`\x03_`\x04\x83\x81T\x81\x10a\x1B\x0BWa\x1B\na.\xEDV[[\x90_R` _ \x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ `\x02\x01_\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x15a\x1B\xC6W`\x04\x81\x81T\x81\x10a\x1B\x95Wa\x1B\x94a.\xEDV[[\x90_R` _ \x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x92PPPa\x1B\xDFV[\x80\x80a\x1B\xD1\x90a/zV[\x91PPa\x1A\xE7V[P_\x91PP[\x91\x90PV[_\x80_\x80\x91P_\x92P_\x90P_[`\x04\x80T\x90P\x81\x10\x15a\x1D\x8EW_`\x04\x82\x81T\x81\x10a\x1C\x14Wa\x1C\x13a.\xEDV[[\x90_R` _ \x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P`\x03_\x82s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ `\x02\x01_\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x15\x80a\x1C\xC2WP\x85s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14[\x15a\x1C\xCDWPa\x1D{V[0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xB6c\xBC\xE4\x82\x8B\x8B\x8B`@Q\x85c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x1D\x0C\x94\x93\x92\x91\x90a4\x90V[` `@Q\x80\x83\x03\x81\x86Z\xFA\x92PPP\x80\x15a\x1DFWP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x1DC\x91\x90a-dV[`\x01[a\x1DPWPa\x1D{V[\x84\x81\x11\x80\x15a\x1D^WP\x87\x81\x11[\x15a\x1DxW\x80\x94P\x81\x95P\x87\x81a\x1Du\x91\x90a/\x1AV[\x93P[PP[\x80\x80a\x1D\x86\x90a/zV[\x91PPa\x1B\xF2V[P\x94P\x94P\x94\x91PPV[\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\t^\xA7\xB3\x86\x84`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x1D\xD4\x92\x91\x90a/\xC1V[` `@Q\x80\x83\x03\x81_\x87Z\xF1\x15\x80\x15a\x1D\xF0W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x1E\x14\x91\x90a/\xFCV[P_`\x02g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x1E1Wa\x1E0a)\x0FV[[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\x1E_W\x81` \x01` \x82\x02\x806\x837\x80\x82\x01\x91PP\x90P[P\x90P\x84\x81_\x81Q\x81\x10a\x1EvWa\x1Eua.\xEDV[[` \x02` \x01\x01\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81RPP\x83\x81`\x01\x81Q\x81\x10a\x1E\xC5Wa\x1E\xC4a.\xEDV[[` \x02` \x01\x01\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81RPP\x85s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c8\xED\x179\x84\x84\x840a\x01,Ba\x1F-\x91\x90a-\x1DV[`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x1FM\x95\x94\x93\x92\x91\x90a4\xD3V[_`@Q\x80\x83\x03\x81_\x87Z\xF1\x92PPP\x80\x15a\x1F\x8BWP`@Q=_\x82>=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x1F\x88\x91\x90a1\xBDV[`\x01[a\x1F\xC1W`@Q\x7F\xCE\x07NW\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[PPPPPPPV[`\x01\x80\x81\x90UPV[a\x1F\xDBa\"\xF3V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x1F\xF9a\x12<V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a XWa \x1Ca\"\xF3V[`@Q\x7F\x11\x8C\xDA\xA7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a O\x91\x90a'\x95V[`@Q\x80\x91\x03\x90\xFD[V[0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\t[\xF9#\x86\x86\x86\x86\x86`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a \x9B\x95\x94\x93\x92\x91\x90a5+V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a \xB2W_\x80\xFD[PZ\xF1\x92PPP\x80\x15a \xC3WP`\x01[a!\x96Wa \xCFa5\x88V[\x80c\x08\xC3y\xA0\x03a!BWPa \xE3a5\xA7V[\x80a \xEEWPa!DV[\x85s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\x1E\xB7\xE9nam\x000\xB6P\xF8X\xD8&<\xCA\xF2\xDB\x08\x8E)\xA0O\x01o\x8E\xAF\x9Ae/m,\x82`@Qa!4\x91\x90a4pV[`@Q\x80\x91\x03\x90\xA2Pa!\x91V[P[\x84s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\x1E\xB7\xE9nam\x000\xB6P\xF8X\xD8&<\xCA\xF2\xDB\x08\x8E)\xA0O\x01o\x8E\xAF\x9Ae/m,`@Qa!\x88\x90a6\x80V[`@Q\x80\x91\x03\x90\xA2[a!\x97V[[PPPPPV[_\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x10a\"\0W\x81\x83`@Q` \x01a!\xE5\x92\x91\x90a6\x9EV[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 a\"*V[\x82\x82`@Q` \x01a\"\x13\x92\x91\x90a6\x9EV[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 [\x90P\x92\x91PPV[_\x80_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x81_\x80a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\x8B\xE0\x07\x9CS\x16Y\x14\x13D\xCD\x1F\xD0\xA4\xF2\x84\x19I\x7F\x97\"\xA3\xDA\xAF\xE3\xB4\x18okdW\xE0`@Q`@Q\x80\x91\x03\x90\xA3PPV[_3\x90P\x90V[`@Q\x80``\x01`@R\x80_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01``\x81R` \x01_\x15\x15\x81RP\x90V[_`@Q\x90P\x90V[_\x80\xFD[_\x80\xFD[_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[_a#k\x82a#BV[\x90P\x91\x90PV[a#{\x81a#aV[\x81\x14a#\x85W_\x80\xFD[PV[_\x815\x90Pa#\x96\x81a#rV[\x92\x91PPV[_\x81\x90P\x91\x90PV[a#\xAE\x81a#\x9CV[\x81\x14a#\xB8W_\x80\xFD[PV[_\x815\x90Pa#\xC9\x81a#\xA5V[\x92\x91PPV[_\x80_\x80_`\xA0\x86\x88\x03\x12\x15a#\xE8Wa#\xE7a#:V[[_a#\xF5\x88\x82\x89\x01a#\x88V[\x95PP` a$\x06\x88\x82\x89\x01a#\xBBV[\x94PP`@a$\x17\x88\x82\x89\x01a#\xBBV[\x93PP``a$(\x88\x82\x89\x01a#\xBBV[\x92PP`\x80a$9\x88\x82\x89\x01a#\xBBV[\x91PP\x92\x95P\x92\x95\x90\x93PV[a$O\x81a#\x9CV[\x82RPPV[_` \x82\x01\x90Pa$h_\x83\x01\x84a$FV[\x92\x91PPV[_` \x82\x84\x03\x12\x15a$\x83Wa$\x82a#:V[[_a$\x90\x84\x82\x85\x01a#\x88V[\x91PP\x92\x91PPV[a$\xA2\x81a#aV[\x82RPPV[_\x81Q\x90P\x91\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_[\x83\x81\x10\x15a$\xDFW\x80\x82\x01Q\x81\x84\x01R` \x81\x01\x90Pa$\xC4V[_\x84\x84\x01RPPPPV[_`\x1F\x19`\x1F\x83\x01\x16\x90P\x91\x90PV[_a%\x04\x82a$\xA8V[a%\x0E\x81\x85a$\xB2V[\x93Pa%\x1E\x81\x85` \x86\x01a$\xC2V[a%'\x81a$\xEAV[\x84\x01\x91PP\x92\x91PPV[_\x81\x15\x15\x90P\x91\x90PV[a%F\x81a%2V[\x82RPPV[_``\x83\x01_\x83\x01Qa%a_\x86\x01\x82a$\x99V[P` \x83\x01Q\x84\x82\x03` \x86\x01Ra%y\x82\x82a$\xFAV[\x91PP`@\x83\x01Qa%\x8E`@\x86\x01\x82a%=V[P\x80\x91PP\x92\x91PPV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra%\xB1\x81\x84a%LV[\x90P\x92\x91PPV[_\x81\x90P\x91\x90PV[a%\xCB\x81a%\xB9V[\x81\x14a%\xD5W_\x80\xFD[PV[_\x815\x90Pa%\xE6\x81a%\xC2V[\x92\x91PPV[_\x80\xFD[_\x80\xFD[_\x80\xFD[_\x80\x83`\x1F\x84\x01\x12a&\rWa&\x0Ca%\xECV[[\x825\x90Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a&*Wa&)a%\xF0V[[` \x83\x01\x91P\x83`\x01\x82\x02\x83\x01\x11\x15a&FWa&Ea%\xF4V[[\x92P\x92\x90PV[_\x80_\x80_\x80_`\xC0\x88\x8A\x03\x12\x15a&hWa&ga#:V[[_a&u\x8A\x82\x8B\x01a#\x88V[\x97PP` a&\x86\x8A\x82\x8B\x01a%\xD8V[\x96PP`@a&\x97\x8A\x82\x8B\x01a%\xD8V[\x95PP``a&\xA8\x8A\x82\x8B\x01a%\xD8V[\x94PP`\x80a&\xB9\x8A\x82\x8B\x01a%\xD8V[\x93PP`\xA0\x88\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a&\xDAWa&\xD9a#>V[[a&\xE6\x8A\x82\x8B\x01a%\xF8V[\x92P\x92PP\x92\x95\x98\x91\x94\x97P\x92\x95PV[_\x80_\x80`\x80\x85\x87\x03\x12\x15a'\x0FWa'\x0Ea#:V[[_a'\x1C\x87\x82\x88\x01a#\x88V[\x94PP` a'-\x87\x82\x88\x01a#\x88V[\x93PP`@a'>\x87\x82\x88\x01a#\x88V[\x92PP``a'O\x87\x82\x88\x01a#\x88V[\x91PP\x92\x95\x91\x94P\x92PV[_` \x82\x84\x03\x12\x15a'pWa'oa#:V[[_a'}\x84\x82\x85\x01a#\xBBV[\x91PP\x92\x91PPV[a'\x8F\x81a#aV[\x82RPPV[_` \x82\x01\x90Pa'\xA8_\x83\x01\x84a'\x86V[\x92\x91PPV[a'\xB7\x81a%2V[\x81\x14a'\xC1W_\x80\xFD[PV[_\x815\x90Pa'\xD2\x81a'\xAEV[\x92\x91PPV[_\x80`@\x83\x85\x03\x12\x15a'\xEEWa'\xEDa#:V[[_a'\xFB\x85\x82\x86\x01a#\x88V[\x92PP` a(\x0C\x85\x82\x86\x01a'\xC4V[\x91PP\x92P\x92\x90PV[a(\x1F\x81a%2V[\x82RPPV[_` \x82\x01\x90Pa(8_\x83\x01\x84a(\x16V[\x92\x91PPV[_\x80`@\x83\x85\x03\x12\x15a(TWa(Sa#:V[[_a(a\x85\x82\x86\x01a#\x88V[\x92PP` a(r\x85\x82\x86\x01a#\xBBV[\x91PP\x92P\x92\x90PV[_` \x82\x84\x03\x12\x15a(\x91Wa(\x90a#:V[[_a(\x9E\x84\x82\x85\x01a%\xD8V[\x91PP\x92\x91PPV[_\x80_\x80`\x80\x85\x87\x03\x12\x15a(\xBFWa(\xBEa#:V[[_a(\xCC\x87\x82\x88\x01a#\x88V[\x94PP` a(\xDD\x87\x82\x88\x01a#\x88V[\x93PP`@a(\xEE\x87\x82\x88\x01a#\x88V[\x92PP``a(\xFF\x87\x82\x88\x01a#\xBBV[\x91PP\x92\x95\x91\x94P\x92PV[_\x80\xFD[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`A`\x04R`$_\xFD[a)E\x82a$\xEAV[\x81\x01\x81\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17\x15a)dWa)ca)\x0FV[[\x80`@RPPPV[_a)va#1V[\x90Pa)\x82\x82\x82a)<V[\x91\x90PV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15a)\xA1Wa)\xA0a)\x0FV[[a)\xAA\x82a$\xEAV[\x90P` \x81\x01\x90P\x91\x90PV[\x82\x81\x837_\x83\x83\x01RPPPV[_a)\xD7a)\xD2\x84a)\x87V[a)mV[\x90P\x82\x81R` \x81\x01\x84\x84\x84\x01\x11\x15a)\xF3Wa)\xF2a)\x0BV[[a)\xFE\x84\x82\x85a)\xB7V[P\x93\x92PPPV[_\x82`\x1F\x83\x01\x12a*\x1AWa*\x19a%\xECV[[\x815a**\x84\x82` \x86\x01a)\xC5V[\x91PP\x92\x91PPV[_\x80`@\x83\x85\x03\x12\x15a*IWa*Ha#:V[[_a*V\x85\x82\x86\x01a#\x88V[\x92PP` \x83\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a*wWa*va#>V[[a*\x83\x85\x82\x86\x01a*\x06V[\x91PP\x92P\x92\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_a*\xA7\x82a$\xA8V[a*\xB1\x81\x85a*\x8DV[\x93Pa*\xC1\x81\x85` \x86\x01a$\xC2V[a*\xCA\x81a$\xEAV[\x84\x01\x91PP\x92\x91PPV[_``\x82\x01\x90Pa*\xE8_\x83\x01\x86a'\x86V[\x81\x81\x03` \x83\x01Ra*\xFA\x81\x85a*\x9DV[\x90Pa+\t`@\x83\x01\x84a(\x16V[\x94\x93PPPPV[\x7FInternal only\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_a+E`\r\x83a*\x8DV[\x91Pa+P\x82a+\x11V[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra+r\x81a+9V[\x90P\x91\x90PV[_\x81Q\x90Pa+\x87\x81a#rV[\x92\x91PPV[_` \x82\x84\x03\x12\x15a+\xA2Wa+\xA1a#:V[[_a+\xAF\x84\x82\x85\x01a+yV[\x91PP\x92\x91PPV[\x7FUnauthorized tokens\0\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_a+\xEC`\x13\x83a*\x8DV[\x91Pa+\xF7\x82a+\xB8V[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra,\x19\x81a+\xE0V[\x90P\x91\x90PV[\x7FInvalid swap amounts\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_a,T`\x14\x83a*\x8DV[\x91Pa,_\x82a, V[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra,\x81\x81a,HV[\x90P\x91\x90PV[\x7FPrimary DEX not found\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_a,\xBC`\x15\x83a*\x8DV[\x91Pa,\xC7\x82a,\x88V[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra,\xE9\x81a,\xB0V[\x90P\x91\x90PV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x11`\x04R`$_\xFD[_a-'\x82a#\x9CV[\x91Pa-2\x83a#\x9CV[\x92P\x82\x82\x01\x90P\x80\x82\x11\x15a-JWa-Ia,\xF0V[[\x92\x91PPV[_\x81Q\x90Pa-^\x81a#\xA5V[\x92\x91PPV[_` \x82\x84\x03\x12\x15a-yWa-xa#:V[[_a-\x86\x84\x82\x85\x01a-PV[\x91PP\x92\x91PPV[\x7FNo balance for arbitrage\0\0\0\0\0\0\0\0_\x82\x01RPV[_a-\xC3`\x18\x83a*\x8DV[\x91Pa-\xCE\x82a-\x8FV[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra-\xF0\x81a-\xB7V[\x90P\x91\x90PV[_``\x82\x01\x90Pa.\n_\x83\x01\x86a'\x86V[a.\x17` \x83\x01\x85a$FV[a.$`@\x83\x01\x84a$FV[\x94\x93PPPPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\"`\x04R`$_\xFD[_`\x02\x82\x04\x90P`\x01\x82\x16\x80a.pW`\x7F\x82\x16\x91P[` \x82\x10\x81\x03a.\x83Wa.\x82a.,V[[P\x91\x90PV[_\x80_\x80`\x80\x85\x87\x03\x12\x15a.\xA1Wa.\xA0a#:V[[_a.\xAE\x87\x82\x88\x01a#\xBBV[\x94PP` a.\xBF\x87\x82\x88\x01a#\xBBV[\x93PP`@a.\xD0\x87\x82\x88\x01a#\xBBV[\x92PP``a.\xE1\x87\x82\x88\x01a#\xBBV[\x91PP\x92\x95\x91\x94P\x92PV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`2`\x04R`$_\xFD[_a/$\x82a#\x9CV[\x91Pa//\x83a#\x9CV[\x92P\x82\x82\x03\x90P\x81\x81\x11\x15a/GWa/Fa,\xF0V[[\x92\x91PPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`1`\x04R`$_\xFD[_a/\x84\x82a#\x9CV[\x91P\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x03a/\xB6Wa/\xB5a,\xF0V[[`\x01\x82\x01\x90P\x91\x90PV[_`@\x82\x01\x90Pa/\xD4_\x83\x01\x85a'\x86V[a/\xE1` \x83\x01\x84a$FV[\x93\x92PPPV[_\x81Q\x90Pa/\xF6\x81a'\xAEV[\x92\x91PPV[_` \x82\x84\x03\x12\x15a0\x11Wa0\x10a#:V[[_a0\x1E\x84\x82\x85\x01a/\xE8V[\x91PP\x92\x91PPV[_\x81Q\x90P\x91\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_\x81\x90P` \x82\x01\x90P\x91\x90PV[_a0[\x83\x83a$\x99V[` \x83\x01\x90P\x92\x91PPV[_` \x82\x01\x90P\x91\x90PV[_a0}\x82a0'V[a0\x87\x81\x85a01V[\x93Pa0\x92\x83a0AV[\x80_[\x83\x81\x10\x15a0\xC2W\x81Qa0\xA9\x88\x82a0PV[\x97Pa0\xB4\x83a0gV[\x92PP`\x01\x81\x01\x90Pa0\x95V[P\x85\x93PPPP\x92\x91PPV[_`@\x82\x01\x90Pa0\xE2_\x83\x01\x85a$FV[\x81\x81\x03` \x83\x01Ra0\xF4\x81\x84a0sV[\x90P\x93\x92PPPV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15a1\x17Wa1\x16a)\x0FV[[` \x82\x02\x90P` \x81\x01\x90P\x91\x90PV[_a1:a15\x84a0\xFDV[a)mV[\x90P\x80\x83\x82R` \x82\x01\x90P` \x84\x02\x83\x01\x85\x81\x11\x15a1]Wa1\\a%\xF4V[[\x83[\x81\x81\x10\x15a1\x86W\x80a1r\x88\x82a-PV[\x84R` \x84\x01\x93PP` \x81\x01\x90Pa1_V[PPP\x93\x92PPPV[_\x82`\x1F\x83\x01\x12a1\xA4Wa1\xA3a%\xECV[[\x81Qa1\xB4\x84\x82` \x86\x01a1(V[\x91PP\x92\x91PPV[_` \x82\x84\x03\x12\x15a1\xD2Wa1\xD1a#:V[[_\x82\x01Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a1\xEFWa1\xEEa#>V[[a1\xFB\x84\x82\x85\x01a1\x90V[\x91PP\x92\x91PPV[_\x81\x90P\x81_R` _ \x90P\x91\x90PV[_` `\x1F\x83\x01\x04\x90P\x91\x90PV[_\x82\x82\x1B\x90P\x92\x91PPV[_`\x08\x83\x02a2`\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82a2%V[a2j\x86\x83a2%V[\x95P\x80\x19\x84\x16\x93P\x80\x86\x16\x84\x17\x92PPP\x93\x92PPPV[_\x81\x90P\x91\x90PV[_a2\xA5a2\xA0a2\x9B\x84a#\x9CV[a2\x82V[a#\x9CV[\x90P\x91\x90PV[_\x81\x90P\x91\x90PV[a2\xBE\x83a2\x8BV[a2\xD2a2\xCA\x82a2\xACV[\x84\x84Ta21V[\x82UPPPPV[_\x90V[a2\xE6a2\xDAV[a2\xF1\x81\x84\x84a2\xB5V[PPPV[[\x81\x81\x10\x15a3\x14Wa3\t_\x82a2\xDEV[`\x01\x81\x01\x90Pa2\xF7V[PPV[`\x1F\x82\x11\x15a3YWa3*\x81a2\x04V[a33\x84a2\x16V[\x81\x01` \x85\x10\x15a3BW\x81\x90P[a3Va3N\x85a2\x16V[\x83\x01\x82a2\xF6V[PP[PPPV[_\x82\x82\x1C\x90P\x92\x91PPV[_a3y_\x19\x84`\x08\x02a3^V[\x19\x80\x83\x16\x91PP\x92\x91PPV[_a3\x91\x83\x83a3jV[\x91P\x82`\x02\x02\x82\x17\x90P\x92\x91PPV[a3\xAA\x82a$\xA8V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a3\xC3Wa3\xC2a)\x0FV[[a3\xCD\x82Ta.YV[a3\xD8\x82\x82\x85a3\x18V[_` \x90P`\x1F\x83\x11`\x01\x81\x14a4\tW_\x84\x15a3\xF7W\x82\x87\x01Q\x90P[a4\x01\x85\x82a3\x86V[\x86UPa4hV[`\x1F\x19\x84\x16a4\x17\x86a2\x04V[_[\x82\x81\x10\x15a4>W\x84\x89\x01Q\x82U`\x01\x82\x01\x91P` \x85\x01\x94P` \x81\x01\x90Pa4\x19V[\x86\x83\x10\x15a4[W\x84\x89\x01Qa4W`\x1F\x89\x16\x82a3jV[\x83UP[`\x01`\x02\x88\x02\x01\x88UPPP[PPPPPPV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra4\x88\x81\x84a*\x9DV[\x90P\x92\x91PPV[_`\x80\x82\x01\x90Pa4\xA3_\x83\x01\x87a'\x86V[a4\xB0` \x83\x01\x86a'\x86V[a4\xBD`@\x83\x01\x85a'\x86V[a4\xCA``\x83\x01\x84a$FV[\x95\x94PPPPPV[_`\xA0\x82\x01\x90Pa4\xE6_\x83\x01\x88a$FV[a4\xF3` \x83\x01\x87a$FV[\x81\x81\x03`@\x83\x01Ra5\x05\x81\x86a0sV[\x90Pa5\x14``\x83\x01\x85a'\x86V[a5!`\x80\x83\x01\x84a$FV[\x96\x95PPPPPPV[_`\xA0\x82\x01\x90Pa5>_\x83\x01\x88a'\x86V[a5K` \x83\x01\x87a$FV[a5X`@\x83\x01\x86a$FV[a5e``\x83\x01\x85a$FV[a5r`\x80\x83\x01\x84a$FV[\x96\x95PPPPPPV[_\x81`\xE0\x1C\x90P\x91\x90PV[_`\x03=\x11\x15a5\xA4W`\x04_\x80>a5\xA1_Qa5|V[\x90P[\x90V[_`D=\x10a63Wa5\xB8a#1V[`\x04=\x03`\x04\x82>\x80Q=`$\x82\x01\x11g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17\x15a5\xE0WPPa63V[\x80\x82\x01\x80Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a5\xFEWPPPPa63V[\x80` \x83\x01\x01`\x04=\x03\x85\x01\x81\x11\x15a6\x1BWPPPPPa63V[a6*\x82` \x01\x85\x01\x86a)<V[\x82\x95PPPPPP[\x90V[\x7FUnknown error\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_a6j`\r\x83a*\x8DV[\x91Pa6u\x82a66V[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra6\x97\x81a6^V[\x90P\x91\x90PV[_`@\x82\x01\x90Pa6\xB1_\x83\x01\x85a'\x86V[a6\xBE` \x83\x01\x84a'\x86V[\x93\x92PPPV\xFE\xA2dipfsX\"\x12 LZV\x88\x851\x07hU\xDB#\x13\xD6\xED\x0E\xCC\x88}_+\xBE\"\xB4\xDE)X\xF3\x8F3\xB2m\xD9dsolcC\0\x08\x14\x003",
    );
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**```solidity
struct DEXConfig { address router; string name; bool enabled; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DEXConfig {
        #[allow(missing_docs)]
        pub router: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub name: alloy::sol_types::private::String,
        #[allow(missing_docs)]
        pub enabled: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::String,
            alloy::sol_types::sol_data::Bool,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::String,
            bool,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<DEXConfig> for UnderlyingRustTuple<'_> {
            fn from(value: DEXConfig) -> Self {
                (value.router, value.name, value.enabled)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for DEXConfig {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    router: tuple.0,
                    name: tuple.1,
                    enabled: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for DEXConfig {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for DEXConfig {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.router,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.name,
                    ),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.enabled,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for DEXConfig {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for DEXConfig {
            const NAME: &'static str = "DEXConfig";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "DEXConfig(address router,string name,bool enabled)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.router,
                        )
                        .0,
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::eip712_data_word(
                            &self.name,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::eip712_data_word(
                            &self.enabled,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for DEXConfig {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.router,
                    )
                    + <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.name,
                    )
                    + <alloy::sol_types::sol_data::Bool as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.enabled,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.router,
                    out,
                );
                <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.name,
                    out,
                );
                <alloy::sol_types::sol_data::Bool as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.enabled,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ArbitrageFailed()` and selector `0xce074e57`.
```solidity
error ArbitrageFailed();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ArbitrageFailed;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ArbitrageFailed> for UnderlyingRustTuple<'_> {
            fn from(value: ArbitrageFailed) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ArbitrageFailed {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ArbitrageFailed {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ArbitrageFailed()";
            const SELECTOR: [u8; 4] = [206u8, 7u8, 78u8, 87u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `DEXNotSupported()` and selector `0x44c28640`.
```solidity
error DEXNotSupported();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DEXNotSupported;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<DEXNotSupported> for UnderlyingRustTuple<'_> {
            fn from(value: DEXNotSupported) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for DEXNotSupported {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for DEXNotSupported {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "DEXNotSupported()";
            const SELECTOR: [u8; 4] = [68u8, 194u8, 134u8, 64u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InsufficientProfit()` and selector `0x4e47f8ea`.
```solidity
error InsufficientProfit();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InsufficientProfit;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InsufficientProfit> for UnderlyingRustTuple<'_> {
            fn from(value: InsufficientProfit) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InsufficientProfit {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InsufficientProfit {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InsufficientProfit()";
            const SELECTOR: [u8; 4] = [78u8, 71u8, 248u8, 234u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidDEXConfig()` and selector `0xb62d9bd8`.
```solidity
error InvalidDEXConfig();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidDEXConfig;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidDEXConfig> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidDEXConfig) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidDEXConfig {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidDEXConfig {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidDEXConfig()";
            const SELECTOR: [u8; 4] = [182u8, 45u8, 155u8, 216u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidEventData()` and selector `0xac66c1e9`.
```solidity
error InvalidEventData();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidEventData;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidEventData> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidEventData) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidEventData {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidEventData {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidEventData()";
            const SELECTOR: [u8; 4] = [172u8, 102u8, 193u8, 233u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `OwnableInvalidOwner(address)` and selector `0x1e4fbdf7`.
```solidity
error OwnableInvalidOwner(address owner);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct OwnableInvalidOwner {
        #[allow(missing_docs)]
        pub owner: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<OwnableInvalidOwner> for UnderlyingRustTuple<'_> {
            fn from(value: OwnableInvalidOwner) -> Self {
                (value.owner,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for OwnableInvalidOwner {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { owner: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for OwnableInvalidOwner {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "OwnableInvalidOwner(address)";
            const SELECTOR: [u8; 4] = [30u8, 79u8, 189u8, 247u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.owner,
                    ),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `OwnableUnauthorizedAccount(address)` and selector `0x118cdaa7`.
```solidity
error OwnableUnauthorizedAccount(address account);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct OwnableUnauthorizedAccount {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<OwnableUnauthorizedAccount>
        for UnderlyingRustTuple<'_> {
            fn from(value: OwnableUnauthorizedAccount) -> Self {
                (value.account,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for OwnableUnauthorizedAccount {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { account: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for OwnableUnauthorizedAccount {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "OwnableUnauthorizedAccount(address)";
            const SELECTOR: [u8; 4] = [17u8, 140u8, 218u8, 167u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ReentrancyGuardReentrantCall()` and selector `0x3ee5aeb5`.
```solidity
error ReentrancyGuardReentrantCall();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ReentrancyGuardReentrantCall;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ReentrancyGuardReentrantCall>
        for UnderlyingRustTuple<'_> {
            fn from(value: ReentrancyGuardReentrantCall) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ReentrancyGuardReentrantCall {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ReentrancyGuardReentrantCall {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ReentrancyGuardReentrantCall()";
            const SELECTOR: [u8; 4] = [62u8, 229u8, 174u8, 181u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `UnauthorizedCaller()` and selector `0x5c427cd9`.
```solidity
error UnauthorizedCaller();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UnauthorizedCaller;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnauthorizedCaller> for UnderlyingRustTuple<'_> {
            fn from(value: UnauthorizedCaller) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for UnauthorizedCaller {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for UnauthorizedCaller {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "UnauthorizedCaller()";
            const SELECTOR: [u8; 4] = [92u8, 66u8, 124u8, 217u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `ArbitrageExecuted(address,address,address,address,uint256,uint256)` and selector `0x9fdefc319d5b857fa8ec2d985b19e06aa8e5b47517c20119b640ef7eb642d00d`.
```solidity
event ArbitrageExecuted(address indexed primaryDEX, address indexed secondaryDEX, address indexed tokenIn, address tokenOut, uint256 amountIn, uint256 profit);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct ArbitrageExecuted {
        #[allow(missing_docs)]
        pub primaryDEX: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub secondaryDEX: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub tokenIn: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub tokenOut: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amountIn: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub profit: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for ArbitrageExecuted {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "ArbitrageExecuted(address,address,address,address,uint256,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                159u8, 222u8, 252u8, 49u8, 157u8, 91u8, 133u8, 127u8, 168u8, 236u8, 45u8,
                152u8, 91u8, 25u8, 224u8, 106u8, 168u8, 229u8, 180u8, 117u8, 23u8, 194u8,
                1u8, 25u8, 182u8, 64u8, 239u8, 126u8, 182u8, 66u8, 208u8, 13u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    primaryDEX: topics.1,
                    secondaryDEX: topics.2,
                    tokenIn: topics.3,
                    tokenOut: data.0,
                    amountIn: data.1,
                    profit: data.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.tokenOut,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amountIn),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.profit),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.primaryDEX.clone(),
                    self.secondaryDEX.clone(),
                    self.tokenIn.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.primaryDEX,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.secondaryDEX,
                );
                out[3usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.tokenIn,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for ArbitrageExecuted {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&ArbitrageExecuted> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &ArbitrageExecuted) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `ArbitrageSkipped(address,string)` and selector `0x1eb7e96e616d0030b650f858d8263ccaf2db088e29a04f016f8eaf9a652f6d2c`.
```solidity
event ArbitrageSkipped(address indexed pair, string reason);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct ArbitrageSkipped {
        #[allow(missing_docs)]
        pub pair: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub reason: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for ArbitrageSkipped {
            type DataTuple<'a> = (alloy::sol_types::sol_data::String,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "ArbitrageSkipped(address,string)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                30u8, 183u8, 233u8, 110u8, 97u8, 109u8, 0u8, 48u8, 182u8, 80u8, 248u8,
                88u8, 216u8, 38u8, 60u8, 202u8, 242u8, 219u8, 8u8, 142u8, 41u8, 160u8,
                79u8, 1u8, 111u8, 142u8, 175u8, 154u8, 101u8, 47u8, 109u8, 44u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    pair: topics.1,
                    reason: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.reason,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.pair.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.pair,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for ArbitrageSkipped {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&ArbitrageSkipped> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &ArbitrageSkipped) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `DEXAdded(address,string)` and selector `0xc4050e82e850253f4929bdbcd143eef487be2fad64739a4f3859e5143745b832`.
```solidity
event DEXAdded(address indexed router, string name);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct DEXAdded {
        #[allow(missing_docs)]
        pub router: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub name: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for DEXAdded {
            type DataTuple<'a> = (alloy::sol_types::sol_data::String,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "DEXAdded(address,string)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                196u8, 5u8, 14u8, 130u8, 232u8, 80u8, 37u8, 63u8, 73u8, 41u8, 189u8,
                188u8, 209u8, 67u8, 238u8, 244u8, 135u8, 190u8, 47u8, 173u8, 100u8,
                115u8, 154u8, 79u8, 56u8, 89u8, 229u8, 20u8, 55u8, 69u8, 184u8, 50u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    router: topics.1,
                    name: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.name,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.router.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.router,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for DEXAdded {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&DEXAdded> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &DEXAdded) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `DEXRemoved(address)` and selector `0x1921ba6698157d491d41801286e9e17aee1c25965119e55403ba396b104b95db`.
```solidity
event DEXRemoved(address indexed router);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct DEXRemoved {
        #[allow(missing_docs)]
        pub router: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for DEXRemoved {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "DEXRemoved(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                25u8, 33u8, 186u8, 102u8, 152u8, 21u8, 125u8, 73u8, 29u8, 65u8, 128u8,
                18u8, 134u8, 233u8, 225u8, 122u8, 238u8, 28u8, 37u8, 150u8, 81u8, 25u8,
                229u8, 84u8, 3u8, 186u8, 57u8, 107u8, 16u8, 75u8, 149u8, 219u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { router: topics.1 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.router.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.router,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for DEXRemoved {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&DEXRemoved> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &DEXRemoved) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `OwnershipTransferred(address,address)` and selector `0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0`.
```solidity
event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct OwnershipTransferred {
        #[allow(missing_docs)]
        pub previousOwner: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub newOwner: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for OwnershipTransferred {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "OwnershipTransferred(address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                139u8, 224u8, 7u8, 156u8, 83u8, 22u8, 89u8, 20u8, 19u8, 68u8, 205u8,
                31u8, 208u8, 164u8, 242u8, 132u8, 25u8, 73u8, 127u8, 151u8, 34u8, 163u8,
                218u8, 175u8, 227u8, 180u8, 24u8, 111u8, 107u8, 100u8, 87u8, 224u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    previousOwner: topics.1,
                    newOwner: topics.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.previousOwner.clone(),
                    self.newOwner.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.previousOwner,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.newOwner,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for OwnershipTransferred {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&OwnershipTransferred> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &OwnershipTransferred) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Constructor`.
```solidity
constructor();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct constructorCall {}
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<constructorCall> for UnderlyingRustTuple<'_> {
                fn from(value: constructorCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for constructorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolConstructor for constructorCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `_executeArbitrageLogic(address,uint256,uint256,uint256,uint256)` and selector `0x095bf923`.
```solidity
function _executeArbitrageLogic(address pairAddress, uint256 amount0In, uint256 amount1In, uint256 amount0Out, uint256 amount1Out) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct _executeArbitrageLogicCall {
        #[allow(missing_docs)]
        pub pairAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amount0In: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub amount1In: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub amount0Out: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub amount1Out: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`_executeArbitrageLogic(address,uint256,uint256,uint256,uint256)`](_executeArbitrageLogicCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct _executeArbitrageLogicReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<_executeArbitrageLogicCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: _executeArbitrageLogicCall) -> Self {
                    (
                        value.pairAddress,
                        value.amount0In,
                        value.amount1In,
                        value.amount0Out,
                        value.amount1Out,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for _executeArbitrageLogicCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        pairAddress: tuple.0,
                        amount0In: tuple.1,
                        amount1In: tuple.2,
                        amount0Out: tuple.3,
                        amount1Out: tuple.4,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<_executeArbitrageLogicReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: _executeArbitrageLogicReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for _executeArbitrageLogicReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl _executeArbitrageLogicReturn {
            fn _tokenize(
                &self,
            ) -> <_executeArbitrageLogicCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for _executeArbitrageLogicCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = _executeArbitrageLogicReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "_executeArbitrageLogic(address,uint256,uint256,uint256,uint256)";
            const SELECTOR: [u8; 4] = [9u8, 91u8, 249u8, 35u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.pairAddress,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount0In),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount1In),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount0Out),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount1Out),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                _executeArbitrageLogicReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `_getAmountOut(address,address,address,uint256)` and selector `0xb663bce4`.
```solidity
function _getAmountOut(address router, address tokenIn, address tokenOut, uint256 amountIn) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct _getAmountOutCall {
        #[allow(missing_docs)]
        pub router: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub tokenIn: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub tokenOut: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amountIn: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`_getAmountOut(address,address,address,uint256)`](_getAmountOutCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct _getAmountOutReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<_getAmountOutCall> for UnderlyingRustTuple<'_> {
                fn from(value: _getAmountOutCall) -> Self {
                    (value.router, value.tokenIn, value.tokenOut, value.amountIn)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for _getAmountOutCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        router: tuple.0,
                        tokenIn: tuple.1,
                        tokenOut: tuple.2,
                        amountIn: tuple.3,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<_getAmountOutReturn> for UnderlyingRustTuple<'_> {
                fn from(value: _getAmountOutReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for _getAmountOutReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for _getAmountOutCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "_getAmountOut(address,address,address,uint256)";
            const SELECTOR: [u8; 4] = [182u8, 99u8, 188u8, 228u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.router,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.tokenIn,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.tokenOut,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amountIn),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: _getAmountOutReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: _getAmountOutReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `addDEX(address,string)` and selector `0xdcbe43d9`.
```solidity
function addDEX(address router, string memory name) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct addDEXCall {
        #[allow(missing_docs)]
        pub router: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub name: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`addDEX(address,string)`](addDEXCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct addDEXReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::String,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::String,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<addDEXCall> for UnderlyingRustTuple<'_> {
                fn from(value: addDEXCall) -> Self {
                    (value.router, value.name)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for addDEXCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        router: tuple.0,
                        name: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<addDEXReturn> for UnderlyingRustTuple<'_> {
                fn from(value: addDEXReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for addDEXReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl addDEXReturn {
            fn _tokenize(
                &self,
            ) -> <addDEXCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for addDEXCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::String,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = addDEXReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "addDEX(address,string)";
            const SELECTOR: [u8; 4] = [220u8, 190u8, 67u8, 217u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.router,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.name,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                addDEXReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `authorizedTokens(address)` and selector `0x9bc7c586`.
```solidity
function authorizedTokens(address) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct authorizedTokensCall(pub alloy::sol_types::private::Address);
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`authorizedTokens(address)`](authorizedTokensCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct authorizedTokensReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<authorizedTokensCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: authorizedTokensCall) -> Self {
                    (value.0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for authorizedTokensCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self(tuple.0)
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<authorizedTokensReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: authorizedTokensReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for authorizedTokensReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for authorizedTokensCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bool;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "authorizedTokens(address)";
            const SELECTOR: [u8; 4] = [155u8, 199u8, 197u8, 134u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.0,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: authorizedTokensReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: authorizedTokensReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `dexConfigs(address)` and selector `0xe7c2269e`.
```solidity
function dexConfigs(address) external view returns (address router, string memory name, bool enabled);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct dexConfigsCall(pub alloy::sol_types::private::Address);
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`dexConfigs(address)`](dexConfigsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct dexConfigsReturn {
        #[allow(missing_docs)]
        pub router: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub name: alloy::sol_types::private::String,
        #[allow(missing_docs)]
        pub enabled: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<dexConfigsCall> for UnderlyingRustTuple<'_> {
                fn from(value: dexConfigsCall) -> Self {
                    (value.0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for dexConfigsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self(tuple.0)
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Bool,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::String,
                bool,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<dexConfigsReturn> for UnderlyingRustTuple<'_> {
                fn from(value: dexConfigsReturn) -> Self {
                    (value.router, value.name, value.enabled)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for dexConfigsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        router: tuple.0,
                        name: tuple.1,
                        enabled: tuple.2,
                    }
                }
            }
        }
        impl dexConfigsReturn {
            fn _tokenize(
                &self,
            ) -> <dexConfigsCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.router,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.name,
                    ),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.enabled,
                    ),
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for dexConfigsCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = dexConfigsReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Bool,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "dexConfigs(address)";
            const SELECTOR: [u8; 4] = [231u8, 194u8, 38u8, 158u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.0,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                dexConfigsReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `gasCostBuffer()` and selector `0x898622e8`.
```solidity
function gasCostBuffer() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct gasCostBufferCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`gasCostBuffer()`](gasCostBufferCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct gasCostBufferReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<gasCostBufferCall> for UnderlyingRustTuple<'_> {
                fn from(value: gasCostBufferCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for gasCostBufferCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<gasCostBufferReturn> for UnderlyingRustTuple<'_> {
                fn from(value: gasCostBufferReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for gasCostBufferReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for gasCostBufferCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "gasCostBuffer()";
            const SELECTOR: [u8; 4] = [137u8, 134u8, 34u8, 232u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: gasCostBufferReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: gasCostBufferReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getDEXInfo(address)` and selector `0x161efb62`.
```solidity
function getDEXInfo(address router) external view returns (DEXConfig memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getDEXInfoCall {
        #[allow(missing_docs)]
        pub router: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getDEXInfo(address)`](getDEXInfoCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getDEXInfoReturn {
        #[allow(missing_docs)]
        pub _0: <DEXConfig as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getDEXInfoCall> for UnderlyingRustTuple<'_> {
                fn from(value: getDEXInfoCall) -> Self {
                    (value.router,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getDEXInfoCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { router: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (DEXConfig,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <DEXConfig as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getDEXInfoReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getDEXInfoReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getDEXInfoReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getDEXInfoCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = <DEXConfig as alloy::sol_types::SolType>::RustType;
            type ReturnTuple<'a> = (DEXConfig,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getDEXInfo(address)";
            const SELECTOR: [u8; 4] = [22u8, 30u8, 251u8, 98u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.router,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (<DEXConfig as alloy_sol_types::SolType>::tokenize(ret),)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getDEXInfoReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getDEXInfoReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getSupportedDEXCount()` and selector `0xd6b2ab24`.
```solidity
function getSupportedDEXCount() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getSupportedDEXCountCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getSupportedDEXCount()`](getSupportedDEXCountCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getSupportedDEXCountReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getSupportedDEXCountCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getSupportedDEXCountCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getSupportedDEXCountCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getSupportedDEXCountReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getSupportedDEXCountReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getSupportedDEXCountReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getSupportedDEXCountCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getSupportedDEXCount()";
            const SELECTOR: [u8; 4] = [214u8, 178u8, 171u8, 36u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getSupportedDEXCountReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getSupportedDEXCountReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `maxTradeSize()` and selector `0x10fa79e2`.
```solidity
function maxTradeSize() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct maxTradeSizeCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`maxTradeSize()`](maxTradeSizeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct maxTradeSizeReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<maxTradeSizeCall> for UnderlyingRustTuple<'_> {
                fn from(value: maxTradeSizeCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for maxTradeSizeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<maxTradeSizeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: maxTradeSizeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for maxTradeSizeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for maxTradeSizeCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "maxTradeSize()";
            const SELECTOR: [u8; 4] = [16u8, 250u8, 121u8, 226u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: maxTradeSizeReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: maxTradeSizeReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `minProfitThreshold()` and selector `0x7341ab8c`.
```solidity
function minProfitThreshold() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct minProfitThresholdCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`minProfitThreshold()`](minProfitThresholdCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct minProfitThresholdReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<minProfitThresholdCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: minProfitThresholdCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for minProfitThresholdCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<minProfitThresholdReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: minProfitThresholdReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for minProfitThresholdReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for minProfitThresholdCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "minProfitThreshold()";
            const SELECTOR: [u8; 4] = [115u8, 65u8, 171u8, 140u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: minProfitThresholdReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: minProfitThresholdReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `onHook(address,bytes32,bytes32,bytes32,bytes32,bytes)` and selector `0x3ea6f207`.
```solidity
function onHook(address contractAddr, bytes32 topic0, bytes32 topic1, bytes32 topic2, bytes32 topic3, bytes memory eventData) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct onHookCall {
        #[allow(missing_docs)]
        pub contractAddr: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub topic0: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub topic1: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub topic2: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub topic3: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub eventData: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`onHook(address,bytes32,bytes32,bytes32,bytes32,bytes)`](onHookCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct onHookReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<onHookCall> for UnderlyingRustTuple<'_> {
                fn from(value: onHookCall) -> Self {
                    (
                        value.contractAddr,
                        value.topic0,
                        value.topic1,
                        value.topic2,
                        value.topic3,
                        value.eventData,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for onHookCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        contractAddr: tuple.0,
                        topic0: tuple.1,
                        topic1: tuple.2,
                        topic2: tuple.3,
                        topic3: tuple.4,
                        eventData: tuple.5,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<onHookReturn> for UnderlyingRustTuple<'_> {
                fn from(value: onHookReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for onHookReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl onHookReturn {
            fn _tokenize(
                &self,
            ) -> <onHookCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for onHookCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = onHookReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "onHook(address,bytes32,bytes32,bytes32,bytes32,bytes)";
            const SELECTOR: [u8; 4] = [62u8, 166u8, 242u8, 7u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.contractAddr,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.topic0),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.topic1),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.topic2),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.topic3),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.eventData,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                onHookReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `owner()` and selector `0x8da5cb5b`.
```solidity
function owner() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ownerCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`owner()`](ownerCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ownerReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ownerCall> for UnderlyingRustTuple<'_> {
                fn from(value: ownerCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ownerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ownerReturn> for UnderlyingRustTuple<'_> {
                fn from(value: ownerReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ownerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for ownerCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "owner()";
            const SELECTOR: [u8; 4] = [141u8, 165u8, 203u8, 91u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: ownerReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: ownerReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `pairRegistry(bytes32)` and selector `0xadb7092a`.
```solidity
function pairRegistry(bytes32) external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pairRegistryCall(pub alloy::sol_types::private::FixedBytes<32>);
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`pairRegistry(bytes32)`](pairRegistryCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pairRegistryReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pairRegistryCall> for UnderlyingRustTuple<'_> {
                fn from(value: pairRegistryCall) -> Self {
                    (value.0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pairRegistryCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self(tuple.0)
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pairRegistryReturn> for UnderlyingRustTuple<'_> {
                fn from(value: pairRegistryReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pairRegistryReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for pairRegistryCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "pairRegistry(bytes32)";
            const SELECTOR: [u8; 4] = [173u8, 183u8, 9u8, 42u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.0),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: pairRegistryReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: pairRegistryReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `pairToDEX(address)` and selector `0xac3c34b8`.
```solidity
function pairToDEX(address) external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pairToDEXCall(pub alloy::sol_types::private::Address);
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`pairToDEX(address)`](pairToDEXCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pairToDEXReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pairToDEXCall> for UnderlyingRustTuple<'_> {
                fn from(value: pairToDEXCall) -> Self {
                    (value.0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pairToDEXCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self(tuple.0)
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pairToDEXReturn> for UnderlyingRustTuple<'_> {
                fn from(value: pairToDEXReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pairToDEXReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for pairToDEXCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "pairToDEX(address)";
            const SELECTOR: [u8; 4] = [172u8, 60u8, 52u8, 184u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.0,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: pairToDEXReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: pairToDEXReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `registerPair(address,address,address,address)` and selector `0x3f8a3467`.
```solidity
function registerPair(address tokenA, address tokenB, address pairAddress, address dexRouter) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct registerPairCall {
        #[allow(missing_docs)]
        pub tokenA: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub tokenB: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub pairAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub dexRouter: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`registerPair(address,address,address,address)`](registerPairCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct registerPairReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<registerPairCall> for UnderlyingRustTuple<'_> {
                fn from(value: registerPairCall) -> Self {
                    (value.tokenA, value.tokenB, value.pairAddress, value.dexRouter)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for registerPairCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        tokenA: tuple.0,
                        tokenB: tuple.1,
                        pairAddress: tuple.2,
                        dexRouter: tuple.3,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<registerPairReturn> for UnderlyingRustTuple<'_> {
                fn from(value: registerPairReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for registerPairReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl registerPairReturn {
            fn _tokenize(
                &self,
            ) -> <registerPairCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for registerPairCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = registerPairReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "registerPair(address,address,address,address)";
            const SELECTOR: [u8; 4] = [63u8, 138u8, 52u8, 103u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.tokenA,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.tokenB,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.pairAddress,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.dexRouter,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                registerPairReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `removeDEX(address)` and selector `0x8c8f3f82`.
```solidity
function removeDEX(address router) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct removeDEXCall {
        #[allow(missing_docs)]
        pub router: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`removeDEX(address)`](removeDEXCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct removeDEXReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<removeDEXCall> for UnderlyingRustTuple<'_> {
                fn from(value: removeDEXCall) -> Self {
                    (value.router,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for removeDEXCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { router: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<removeDEXReturn> for UnderlyingRustTuple<'_> {
                fn from(value: removeDEXReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for removeDEXReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl removeDEXReturn {
            fn _tokenize(
                &self,
            ) -> <removeDEXCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for removeDEXCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = removeDEXReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "removeDEX(address)";
            const SELECTOR: [u8; 4] = [140u8, 143u8, 63u8, 130u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.router,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                removeDEXReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `renounceOwnership()` and selector `0x715018a6`.
```solidity
function renounceOwnership() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceOwnershipCall;
    ///Container type for the return parameters of the [`renounceOwnership()`](renounceOwnershipCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceOwnershipReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceOwnershipCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: renounceOwnershipCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for renounceOwnershipCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceOwnershipReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: renounceOwnershipReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for renounceOwnershipReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl renounceOwnershipReturn {
            fn _tokenize(
                &self,
            ) -> <renounceOwnershipCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for renounceOwnershipCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = renounceOwnershipReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "renounceOwnership()";
            const SELECTOR: [u8; 4] = [113u8, 80u8, 24u8, 166u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                renounceOwnershipReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `sequencer()` and selector `0x5c1bba38`.
```solidity
function sequencer() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct sequencerCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`sequencer()`](sequencerCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct sequencerReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<sequencerCall> for UnderlyingRustTuple<'_> {
                fn from(value: sequencerCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for sequencerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<sequencerReturn> for UnderlyingRustTuple<'_> {
                fn from(value: sequencerReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for sequencerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for sequencerCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "sequencer()";
            const SELECTOR: [u8; 4] = [92u8, 27u8, 186u8, 56u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: sequencerReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: sequencerReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `setAuthorizedToken(address,bool)` and selector `0x53fc838b`.
```solidity
function setAuthorizedToken(address token, bool authorized) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setAuthorizedTokenCall {
        #[allow(missing_docs)]
        pub token: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub authorized: bool,
    }
    ///Container type for the return parameters of the [`setAuthorizedToken(address,bool)`](setAuthorizedTokenCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setAuthorizedTokenReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bool,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address, bool);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setAuthorizedTokenCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: setAuthorizedTokenCall) -> Self {
                    (value.token, value.authorized)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setAuthorizedTokenCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        token: tuple.0,
                        authorized: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setAuthorizedTokenReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setAuthorizedTokenReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setAuthorizedTokenReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl setAuthorizedTokenReturn {
            fn _tokenize(
                &self,
            ) -> <setAuthorizedTokenCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setAuthorizedTokenCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bool,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setAuthorizedTokenReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setAuthorizedToken(address,bool)";
            const SELECTOR: [u8; 4] = [83u8, 252u8, 131u8, 139u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.token,
                    ),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.authorized,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                setAuthorizedTokenReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `setGasCostBuffer(uint256)` and selector `0x82cc696d`.
```solidity
function setGasCostBuffer(uint256 buffer) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setGasCostBufferCall {
        #[allow(missing_docs)]
        pub buffer: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`setGasCostBuffer(uint256)`](setGasCostBufferCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setGasCostBufferReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setGasCostBufferCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: setGasCostBufferCall) -> Self {
                    (value.buffer,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setGasCostBufferCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { buffer: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setGasCostBufferReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setGasCostBufferReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setGasCostBufferReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl setGasCostBufferReturn {
            fn _tokenize(
                &self,
            ) -> <setGasCostBufferCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setGasCostBufferCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setGasCostBufferReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setGasCostBuffer(uint256)";
            const SELECTOR: [u8; 4] = [130u8, 204u8, 105u8, 109u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.buffer),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                setGasCostBufferReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `setMaxTradeSize(uint256)` and selector `0x4b3f3378`.
```solidity
function setMaxTradeSize(uint256 size) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setMaxTradeSizeCall {
        #[allow(missing_docs)]
        pub size: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`setMaxTradeSize(uint256)`](setMaxTradeSizeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setMaxTradeSizeReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setMaxTradeSizeCall> for UnderlyingRustTuple<'_> {
                fn from(value: setMaxTradeSizeCall) -> Self {
                    (value.size,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setMaxTradeSizeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { size: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setMaxTradeSizeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setMaxTradeSizeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setMaxTradeSizeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl setMaxTradeSizeReturn {
            fn _tokenize(
                &self,
            ) -> <setMaxTradeSizeCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setMaxTradeSizeCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setMaxTradeSizeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setMaxTradeSize(uint256)";
            const SELECTOR: [u8; 4] = [75u8, 63u8, 51u8, 120u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.size),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                setMaxTradeSizeReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `setMinProfitThreshold(uint256)` and selector `0xc0286465`.
```solidity
function setMinProfitThreshold(uint256 threshold) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setMinProfitThresholdCall {
        #[allow(missing_docs)]
        pub threshold: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`setMinProfitThreshold(uint256)`](setMinProfitThresholdCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setMinProfitThresholdReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setMinProfitThresholdCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: setMinProfitThresholdCall) -> Self {
                    (value.threshold,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setMinProfitThresholdCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { threshold: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setMinProfitThresholdReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setMinProfitThresholdReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setMinProfitThresholdReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl setMinProfitThresholdReturn {
            fn _tokenize(
                &self,
            ) -> <setMinProfitThresholdCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setMinProfitThresholdCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setMinProfitThresholdReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setMinProfitThreshold(uint256)";
            const SELECTOR: [u8; 4] = [192u8, 40u8, 100u8, 101u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.threshold),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                setMinProfitThresholdReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `setSequencer(address)` and selector `0x2547fa3e`.
```solidity
function setSequencer(address _sequencer) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setSequencerCall {
        #[allow(missing_docs)]
        pub _sequencer: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`setSequencer(address)`](setSequencerCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setSequencerReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setSequencerCall> for UnderlyingRustTuple<'_> {
                fn from(value: setSequencerCall) -> Self {
                    (value._sequencer,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setSequencerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _sequencer: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setSequencerReturn> for UnderlyingRustTuple<'_> {
                fn from(value: setSequencerReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setSequencerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl setSequencerReturn {
            fn _tokenize(
                &self,
            ) -> <setSequencerCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setSequencerCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setSequencerReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setSequencer(address)";
            const SELECTOR: [u8; 4] = [37u8, 71u8, 250u8, 62u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._sequencer,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                setSequencerReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `supportedDEXes(uint256)` and selector `0x4caf81f5`.
```solidity
function supportedDEXes(uint256) external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct supportedDEXesCall(
        pub alloy::sol_types::private::primitives::aliases::U256,
    );
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`supportedDEXes(uint256)`](supportedDEXesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct supportedDEXesReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<supportedDEXesCall> for UnderlyingRustTuple<'_> {
                fn from(value: supportedDEXesCall) -> Self {
                    (value.0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for supportedDEXesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self(tuple.0)
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<supportedDEXesReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: supportedDEXesReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for supportedDEXesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for supportedDEXesCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "supportedDEXes(uint256)";
            const SELECTOR: [u8; 4] = [76u8, 175u8, 129u8, 245u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.0),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: supportedDEXesReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: supportedDEXesReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `transferOwnership(address)` and selector `0xf2fde38b`.
```solidity
function transferOwnership(address newOwner) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferOwnershipCall {
        #[allow(missing_docs)]
        pub newOwner: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`transferOwnership(address)`](transferOwnershipCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferOwnershipReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferOwnershipCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: transferOwnershipCall) -> Self {
                    (value.newOwner,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for transferOwnershipCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { newOwner: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferOwnershipReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: transferOwnershipReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for transferOwnershipReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl transferOwnershipReturn {
            fn _tokenize(
                &self,
            ) -> <transferOwnershipCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for transferOwnershipCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = transferOwnershipReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "transferOwnership(address)";
            const SELECTOR: [u8; 4] = [242u8, 253u8, 227u8, 139u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.newOwner,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                transferOwnershipReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `withdrawETH(uint256)` and selector `0xf14210a6`.
```solidity
function withdrawETH(uint256 amount) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct withdrawETHCall {
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`withdrawETH(uint256)`](withdrawETHCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct withdrawETHReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<withdrawETHCall> for UnderlyingRustTuple<'_> {
                fn from(value: withdrawETHCall) -> Self {
                    (value.amount,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for withdrawETHCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { amount: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<withdrawETHReturn> for UnderlyingRustTuple<'_> {
                fn from(value: withdrawETHReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for withdrawETHReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl withdrawETHReturn {
            fn _tokenize(
                &self,
            ) -> <withdrawETHCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for withdrawETHCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = withdrawETHReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "withdrawETH(uint256)";
            const SELECTOR: [u8; 4] = [241u8, 66u8, 16u8, 166u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                withdrawETHReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `withdrawToken(address,uint256)` and selector `0x9e281a98`.
```solidity
function withdrawToken(address token, uint256 amount) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct withdrawTokenCall {
        #[allow(missing_docs)]
        pub token: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`withdrawToken(address,uint256)`](withdrawTokenCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct withdrawTokenReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<withdrawTokenCall> for UnderlyingRustTuple<'_> {
                fn from(value: withdrawTokenCall) -> Self {
                    (value.token, value.amount)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for withdrawTokenCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        token: tuple.0,
                        amount: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<withdrawTokenReturn> for UnderlyingRustTuple<'_> {
                fn from(value: withdrawTokenReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for withdrawTokenReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl withdrawTokenReturn {
            fn _tokenize(
                &self,
            ) -> <withdrawTokenCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for withdrawTokenCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = withdrawTokenReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "withdrawToken(address,uint256)";
            const SELECTOR: [u8; 4] = [158u8, 40u8, 26u8, 152u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.token,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                withdrawTokenReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    ///Container for all the [`UniswapV2ArbHook`](self) function calls.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive()]
    pub enum UniswapV2ArbHookCalls {
        #[allow(missing_docs)]
        _executeArbitrageLogic(_executeArbitrageLogicCall),
        #[allow(missing_docs)]
        _getAmountOut(_getAmountOutCall),
        #[allow(missing_docs)]
        addDEX(addDEXCall),
        #[allow(missing_docs)]
        authorizedTokens(authorizedTokensCall),
        #[allow(missing_docs)]
        dexConfigs(dexConfigsCall),
        #[allow(missing_docs)]
        gasCostBuffer(gasCostBufferCall),
        #[allow(missing_docs)]
        getDEXInfo(getDEXInfoCall),
        #[allow(missing_docs)]
        getSupportedDEXCount(getSupportedDEXCountCall),
        #[allow(missing_docs)]
        maxTradeSize(maxTradeSizeCall),
        #[allow(missing_docs)]
        minProfitThreshold(minProfitThresholdCall),
        #[allow(missing_docs)]
        onHook(onHookCall),
        #[allow(missing_docs)]
        owner(ownerCall),
        #[allow(missing_docs)]
        pairRegistry(pairRegistryCall),
        #[allow(missing_docs)]
        pairToDEX(pairToDEXCall),
        #[allow(missing_docs)]
        registerPair(registerPairCall),
        #[allow(missing_docs)]
        removeDEX(removeDEXCall),
        #[allow(missing_docs)]
        renounceOwnership(renounceOwnershipCall),
        #[allow(missing_docs)]
        sequencer(sequencerCall),
        #[allow(missing_docs)]
        setAuthorizedToken(setAuthorizedTokenCall),
        #[allow(missing_docs)]
        setGasCostBuffer(setGasCostBufferCall),
        #[allow(missing_docs)]
        setMaxTradeSize(setMaxTradeSizeCall),
        #[allow(missing_docs)]
        setMinProfitThreshold(setMinProfitThresholdCall),
        #[allow(missing_docs)]
        setSequencer(setSequencerCall),
        #[allow(missing_docs)]
        supportedDEXes(supportedDEXesCall),
        #[allow(missing_docs)]
        transferOwnership(transferOwnershipCall),
        #[allow(missing_docs)]
        withdrawETH(withdrawETHCall),
        #[allow(missing_docs)]
        withdrawToken(withdrawTokenCall),
    }
    #[automatically_derived]
    impl UniswapV2ArbHookCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [9u8, 91u8, 249u8, 35u8],
            [16u8, 250u8, 121u8, 226u8],
            [22u8, 30u8, 251u8, 98u8],
            [37u8, 71u8, 250u8, 62u8],
            [62u8, 166u8, 242u8, 7u8],
            [63u8, 138u8, 52u8, 103u8],
            [75u8, 63u8, 51u8, 120u8],
            [76u8, 175u8, 129u8, 245u8],
            [83u8, 252u8, 131u8, 139u8],
            [92u8, 27u8, 186u8, 56u8],
            [113u8, 80u8, 24u8, 166u8],
            [115u8, 65u8, 171u8, 140u8],
            [130u8, 204u8, 105u8, 109u8],
            [137u8, 134u8, 34u8, 232u8],
            [140u8, 143u8, 63u8, 130u8],
            [141u8, 165u8, 203u8, 91u8],
            [155u8, 199u8, 197u8, 134u8],
            [158u8, 40u8, 26u8, 152u8],
            [172u8, 60u8, 52u8, 184u8],
            [173u8, 183u8, 9u8, 42u8],
            [182u8, 99u8, 188u8, 228u8],
            [192u8, 40u8, 100u8, 101u8],
            [214u8, 178u8, 171u8, 36u8],
            [220u8, 190u8, 67u8, 217u8],
            [231u8, 194u8, 38u8, 158u8],
            [241u8, 66u8, 16u8, 166u8],
            [242u8, 253u8, 227u8, 139u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for UniswapV2ArbHookCalls {
        const NAME: &'static str = "UniswapV2ArbHookCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 27usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::_executeArbitrageLogic(_) => {
                    <_executeArbitrageLogicCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::_getAmountOut(_) => {
                    <_getAmountOutCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::addDEX(_) => <addDEXCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::authorizedTokens(_) => {
                    <authorizedTokensCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::dexConfigs(_) => {
                    <dexConfigsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::gasCostBuffer(_) => {
                    <gasCostBufferCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getDEXInfo(_) => {
                    <getDEXInfoCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getSupportedDEXCount(_) => {
                    <getSupportedDEXCountCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::maxTradeSize(_) => {
                    <maxTradeSizeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::minProfitThreshold(_) => {
                    <minProfitThresholdCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::onHook(_) => <onHookCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::owner(_) => <ownerCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::pairRegistry(_) => {
                    <pairRegistryCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::pairToDEX(_) => {
                    <pairToDEXCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::registerPair(_) => {
                    <registerPairCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::removeDEX(_) => {
                    <removeDEXCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::renounceOwnership(_) => {
                    <renounceOwnershipCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::sequencer(_) => {
                    <sequencerCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setAuthorizedToken(_) => {
                    <setAuthorizedTokenCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setGasCostBuffer(_) => {
                    <setGasCostBufferCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setMaxTradeSize(_) => {
                    <setMaxTradeSizeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setMinProfitThreshold(_) => {
                    <setMinProfitThresholdCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setSequencer(_) => {
                    <setSequencerCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::supportedDEXes(_) => {
                    <supportedDEXesCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::transferOwnership(_) => {
                    <transferOwnershipCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::withdrawETH(_) => {
                    <withdrawETHCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::withdrawToken(_) => {
                    <withdrawTokenCall as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<UniswapV2ArbHookCalls>] = &[
                {
                    fn _executeArbitrageLogic(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UniswapV2ArbHookCalls> {
                        <_executeArbitrageLogicCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UniswapV2ArbHookCalls::_executeArbitrageLogic)
                    }
                    _executeArbitrageLogic
                },
                {
                    fn maxTradeSize(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UniswapV2ArbHookCalls> {
                        <maxTradeSizeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UniswapV2ArbHookCalls::maxTradeSize)
                    }
                    maxTradeSize
                },
                {
                    fn getDEXInfo(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UniswapV2ArbHookCalls> {
                        <getDEXInfoCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UniswapV2ArbHookCalls::getDEXInfo)
                    }
                    getDEXInfo
                },
                {
                    fn setSequencer(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UniswapV2ArbHookCalls> {
                        <setSequencerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UniswapV2ArbHookCalls::setSequencer)
                    }
                    setSequencer
                },
                {
                    fn onHook(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UniswapV2ArbHookCalls> {
                        <onHookCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(UniswapV2ArbHookCalls::onHook)
                    }
                    onHook
                },
                {
                    fn registerPair(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UniswapV2ArbHookCalls> {
                        <registerPairCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UniswapV2ArbHookCalls::registerPair)
                    }
                    registerPair
                },
                {
                    fn setMaxTradeSize(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UniswapV2ArbHookCalls> {
                        <setMaxTradeSizeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UniswapV2ArbHookCalls::setMaxTradeSize)
                    }
                    setMaxTradeSize
                },
                {
                    fn supportedDEXes(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UniswapV2ArbHookCalls> {
                        <supportedDEXesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UniswapV2ArbHookCalls::supportedDEXes)
                    }
                    supportedDEXes
                },
                {
                    fn setAuthorizedToken(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UniswapV2ArbHookCalls> {
                        <setAuthorizedTokenCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UniswapV2ArbHookCalls::setAuthorizedToken)
                    }
                    setAuthorizedToken
                },
                {
                    fn sequencer(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UniswapV2ArbHookCalls> {
                        <sequencerCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(UniswapV2ArbHookCalls::sequencer)
                    }
                    sequencer
                },
                {
                    fn renounceOwnership(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UniswapV2ArbHookCalls> {
                        <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UniswapV2ArbHookCalls::renounceOwnership)
                    }
                    renounceOwnership
                },
                {
                    fn minProfitThreshold(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UniswapV2ArbHookCalls> {
                        <minProfitThresholdCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UniswapV2ArbHookCalls::minProfitThreshold)
                    }
                    minProfitThreshold
                },
                {
                    fn setGasCostBuffer(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UniswapV2ArbHookCalls> {
                        <setGasCostBufferCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UniswapV2ArbHookCalls::setGasCostBuffer)
                    }
                    setGasCostBuffer
                },
                {
                    fn gasCostBuffer(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UniswapV2ArbHookCalls> {
                        <gasCostBufferCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UniswapV2ArbHookCalls::gasCostBuffer)
                    }
                    gasCostBuffer
                },
                {
                    fn removeDEX(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UniswapV2ArbHookCalls> {
                        <removeDEXCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(UniswapV2ArbHookCalls::removeDEX)
                    }
                    removeDEX
                },
                {
                    fn owner(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UniswapV2ArbHookCalls> {
                        <ownerCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(UniswapV2ArbHookCalls::owner)
                    }
                    owner
                },
                {
                    fn authorizedTokens(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UniswapV2ArbHookCalls> {
                        <authorizedTokensCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UniswapV2ArbHookCalls::authorizedTokens)
                    }
                    authorizedTokens
                },
                {
                    fn withdrawToken(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UniswapV2ArbHookCalls> {
                        <withdrawTokenCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UniswapV2ArbHookCalls::withdrawToken)
                    }
                    withdrawToken
                },
                {
                    fn pairToDEX(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UniswapV2ArbHookCalls> {
                        <pairToDEXCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(UniswapV2ArbHookCalls::pairToDEX)
                    }
                    pairToDEX
                },
                {
                    fn pairRegistry(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UniswapV2ArbHookCalls> {
                        <pairRegistryCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UniswapV2ArbHookCalls::pairRegistry)
                    }
                    pairRegistry
                },
                {
                    fn _getAmountOut(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UniswapV2ArbHookCalls> {
                        <_getAmountOutCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UniswapV2ArbHookCalls::_getAmountOut)
                    }
                    _getAmountOut
                },
                {
                    fn setMinProfitThreshold(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UniswapV2ArbHookCalls> {
                        <setMinProfitThresholdCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UniswapV2ArbHookCalls::setMinProfitThreshold)
                    }
                    setMinProfitThreshold
                },
                {
                    fn getSupportedDEXCount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UniswapV2ArbHookCalls> {
                        <getSupportedDEXCountCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UniswapV2ArbHookCalls::getSupportedDEXCount)
                    }
                    getSupportedDEXCount
                },
                {
                    fn addDEX(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UniswapV2ArbHookCalls> {
                        <addDEXCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(UniswapV2ArbHookCalls::addDEX)
                    }
                    addDEX
                },
                {
                    fn dexConfigs(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UniswapV2ArbHookCalls> {
                        <dexConfigsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UniswapV2ArbHookCalls::dexConfigs)
                    }
                    dexConfigs
                },
                {
                    fn withdrawETH(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UniswapV2ArbHookCalls> {
                        <withdrawETHCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UniswapV2ArbHookCalls::withdrawETH)
                    }
                    withdrawETH
                },
                {
                    fn transferOwnership(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UniswapV2ArbHookCalls> {
                        <transferOwnershipCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UniswapV2ArbHookCalls::transferOwnership)
                    }
                    transferOwnership
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data)
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw_validate(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_VALIDATE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<UniswapV2ArbHookCalls>] = &[
                {
                    fn _executeArbitrageLogic(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UniswapV2ArbHookCalls> {
                        <_executeArbitrageLogicCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UniswapV2ArbHookCalls::_executeArbitrageLogic)
                    }
                    _executeArbitrageLogic
                },
                {
                    fn maxTradeSize(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UniswapV2ArbHookCalls> {
                        <maxTradeSizeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UniswapV2ArbHookCalls::maxTradeSize)
                    }
                    maxTradeSize
                },
                {
                    fn getDEXInfo(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UniswapV2ArbHookCalls> {
                        <getDEXInfoCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UniswapV2ArbHookCalls::getDEXInfo)
                    }
                    getDEXInfo
                },
                {
                    fn setSequencer(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UniswapV2ArbHookCalls> {
                        <setSequencerCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UniswapV2ArbHookCalls::setSequencer)
                    }
                    setSequencer
                },
                {
                    fn onHook(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UniswapV2ArbHookCalls> {
                        <onHookCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UniswapV2ArbHookCalls::onHook)
                    }
                    onHook
                },
                {
                    fn registerPair(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UniswapV2ArbHookCalls> {
                        <registerPairCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UniswapV2ArbHookCalls::registerPair)
                    }
                    registerPair
                },
                {
                    fn setMaxTradeSize(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UniswapV2ArbHookCalls> {
                        <setMaxTradeSizeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UniswapV2ArbHookCalls::setMaxTradeSize)
                    }
                    setMaxTradeSize
                },
                {
                    fn supportedDEXes(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UniswapV2ArbHookCalls> {
                        <supportedDEXesCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UniswapV2ArbHookCalls::supportedDEXes)
                    }
                    supportedDEXes
                },
                {
                    fn setAuthorizedToken(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UniswapV2ArbHookCalls> {
                        <setAuthorizedTokenCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UniswapV2ArbHookCalls::setAuthorizedToken)
                    }
                    setAuthorizedToken
                },
                {
                    fn sequencer(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UniswapV2ArbHookCalls> {
                        <sequencerCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UniswapV2ArbHookCalls::sequencer)
                    }
                    sequencer
                },
                {
                    fn renounceOwnership(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UniswapV2ArbHookCalls> {
                        <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UniswapV2ArbHookCalls::renounceOwnership)
                    }
                    renounceOwnership
                },
                {
                    fn minProfitThreshold(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UniswapV2ArbHookCalls> {
                        <minProfitThresholdCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UniswapV2ArbHookCalls::minProfitThreshold)
                    }
                    minProfitThreshold
                },
                {
                    fn setGasCostBuffer(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UniswapV2ArbHookCalls> {
                        <setGasCostBufferCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UniswapV2ArbHookCalls::setGasCostBuffer)
                    }
                    setGasCostBuffer
                },
                {
                    fn gasCostBuffer(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UniswapV2ArbHookCalls> {
                        <gasCostBufferCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UniswapV2ArbHookCalls::gasCostBuffer)
                    }
                    gasCostBuffer
                },
                {
                    fn removeDEX(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UniswapV2ArbHookCalls> {
                        <removeDEXCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UniswapV2ArbHookCalls::removeDEX)
                    }
                    removeDEX
                },
                {
                    fn owner(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UniswapV2ArbHookCalls> {
                        <ownerCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UniswapV2ArbHookCalls::owner)
                    }
                    owner
                },
                {
                    fn authorizedTokens(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UniswapV2ArbHookCalls> {
                        <authorizedTokensCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UniswapV2ArbHookCalls::authorizedTokens)
                    }
                    authorizedTokens
                },
                {
                    fn withdrawToken(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UniswapV2ArbHookCalls> {
                        <withdrawTokenCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UniswapV2ArbHookCalls::withdrawToken)
                    }
                    withdrawToken
                },
                {
                    fn pairToDEX(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UniswapV2ArbHookCalls> {
                        <pairToDEXCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UniswapV2ArbHookCalls::pairToDEX)
                    }
                    pairToDEX
                },
                {
                    fn pairRegistry(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UniswapV2ArbHookCalls> {
                        <pairRegistryCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UniswapV2ArbHookCalls::pairRegistry)
                    }
                    pairRegistry
                },
                {
                    fn _getAmountOut(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UniswapV2ArbHookCalls> {
                        <_getAmountOutCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UniswapV2ArbHookCalls::_getAmountOut)
                    }
                    _getAmountOut
                },
                {
                    fn setMinProfitThreshold(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UniswapV2ArbHookCalls> {
                        <setMinProfitThresholdCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UniswapV2ArbHookCalls::setMinProfitThreshold)
                    }
                    setMinProfitThreshold
                },
                {
                    fn getSupportedDEXCount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UniswapV2ArbHookCalls> {
                        <getSupportedDEXCountCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UniswapV2ArbHookCalls::getSupportedDEXCount)
                    }
                    getSupportedDEXCount
                },
                {
                    fn addDEX(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UniswapV2ArbHookCalls> {
                        <addDEXCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UniswapV2ArbHookCalls::addDEX)
                    }
                    addDEX
                },
                {
                    fn dexConfigs(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UniswapV2ArbHookCalls> {
                        <dexConfigsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UniswapV2ArbHookCalls::dexConfigs)
                    }
                    dexConfigs
                },
                {
                    fn withdrawETH(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UniswapV2ArbHookCalls> {
                        <withdrawETHCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UniswapV2ArbHookCalls::withdrawETH)
                    }
                    withdrawETH
                },
                {
                    fn transferOwnership(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UniswapV2ArbHookCalls> {
                        <transferOwnershipCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UniswapV2ArbHookCalls::transferOwnership)
                    }
                    transferOwnership
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_VALIDATE_SHIMS[idx](data)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::_executeArbitrageLogic(inner) => {
                    <_executeArbitrageLogicCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::_getAmountOut(inner) => {
                    <_getAmountOutCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::addDEX(inner) => {
                    <addDEXCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::authorizedTokens(inner) => {
                    <authorizedTokensCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::dexConfigs(inner) => {
                    <dexConfigsCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::gasCostBuffer(inner) => {
                    <gasCostBufferCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getDEXInfo(inner) => {
                    <getDEXInfoCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::getSupportedDEXCount(inner) => {
                    <getSupportedDEXCountCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::maxTradeSize(inner) => {
                    <maxTradeSizeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::minProfitThreshold(inner) => {
                    <minProfitThresholdCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::onHook(inner) => {
                    <onHookCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::owner(inner) => {
                    <ownerCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::pairRegistry(inner) => {
                    <pairRegistryCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::pairToDEX(inner) => {
                    <pairToDEXCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::registerPair(inner) => {
                    <registerPairCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::removeDEX(inner) => {
                    <removeDEXCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::renounceOwnership(inner) => {
                    <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::sequencer(inner) => {
                    <sequencerCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::setAuthorizedToken(inner) => {
                    <setAuthorizedTokenCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setGasCostBuffer(inner) => {
                    <setGasCostBufferCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setMaxTradeSize(inner) => {
                    <setMaxTradeSizeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setMinProfitThreshold(inner) => {
                    <setMinProfitThresholdCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setSequencer(inner) => {
                    <setSequencerCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::supportedDEXes(inner) => {
                    <supportedDEXesCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::transferOwnership(inner) => {
                    <transferOwnershipCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::withdrawETH(inner) => {
                    <withdrawETHCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::withdrawToken(inner) => {
                    <withdrawTokenCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::_executeArbitrageLogic(inner) => {
                    <_executeArbitrageLogicCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::_getAmountOut(inner) => {
                    <_getAmountOutCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::addDEX(inner) => {
                    <addDEXCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::authorizedTokens(inner) => {
                    <authorizedTokensCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::dexConfigs(inner) => {
                    <dexConfigsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::gasCostBuffer(inner) => {
                    <gasCostBufferCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getDEXInfo(inner) => {
                    <getDEXInfoCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getSupportedDEXCount(inner) => {
                    <getSupportedDEXCountCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::maxTradeSize(inner) => {
                    <maxTradeSizeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::minProfitThreshold(inner) => {
                    <minProfitThresholdCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::onHook(inner) => {
                    <onHookCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::owner(inner) => {
                    <ownerCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::pairRegistry(inner) => {
                    <pairRegistryCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::pairToDEX(inner) => {
                    <pairToDEXCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::registerPair(inner) => {
                    <registerPairCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::removeDEX(inner) => {
                    <removeDEXCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::renounceOwnership(inner) => {
                    <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::sequencer(inner) => {
                    <sequencerCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setAuthorizedToken(inner) => {
                    <setAuthorizedTokenCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setGasCostBuffer(inner) => {
                    <setGasCostBufferCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setMaxTradeSize(inner) => {
                    <setMaxTradeSizeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setMinProfitThreshold(inner) => {
                    <setMinProfitThresholdCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setSequencer(inner) => {
                    <setSequencerCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::supportedDEXes(inner) => {
                    <supportedDEXesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::transferOwnership(inner) => {
                    <transferOwnershipCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::withdrawETH(inner) => {
                    <withdrawETHCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::withdrawToken(inner) => {
                    <withdrawTokenCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`UniswapV2ArbHook`](self) custom errors.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub enum UniswapV2ArbHookErrors {
        #[allow(missing_docs)]
        ArbitrageFailed(ArbitrageFailed),
        #[allow(missing_docs)]
        DEXNotSupported(DEXNotSupported),
        #[allow(missing_docs)]
        InsufficientProfit(InsufficientProfit),
        #[allow(missing_docs)]
        InvalidDEXConfig(InvalidDEXConfig),
        #[allow(missing_docs)]
        InvalidEventData(InvalidEventData),
        #[allow(missing_docs)]
        OwnableInvalidOwner(OwnableInvalidOwner),
        #[allow(missing_docs)]
        OwnableUnauthorizedAccount(OwnableUnauthorizedAccount),
        #[allow(missing_docs)]
        ReentrancyGuardReentrantCall(ReentrancyGuardReentrantCall),
        #[allow(missing_docs)]
        UnauthorizedCaller(UnauthorizedCaller),
    }
    #[automatically_derived]
    impl UniswapV2ArbHookErrors {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [17u8, 140u8, 218u8, 167u8],
            [30u8, 79u8, 189u8, 247u8],
            [62u8, 229u8, 174u8, 181u8],
            [68u8, 194u8, 134u8, 64u8],
            [78u8, 71u8, 248u8, 234u8],
            [92u8, 66u8, 124u8, 217u8],
            [172u8, 102u8, 193u8, 233u8],
            [182u8, 45u8, 155u8, 216u8],
            [206u8, 7u8, 78u8, 87u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for UniswapV2ArbHookErrors {
        const NAME: &'static str = "UniswapV2ArbHookErrors";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 9usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::ArbitrageFailed(_) => {
                    <ArbitrageFailed as alloy_sol_types::SolError>::SELECTOR
                }
                Self::DEXNotSupported(_) => {
                    <DEXNotSupported as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InsufficientProfit(_) => {
                    <InsufficientProfit as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidDEXConfig(_) => {
                    <InvalidDEXConfig as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidEventData(_) => {
                    <InvalidEventData as alloy_sol_types::SolError>::SELECTOR
                }
                Self::OwnableInvalidOwner(_) => {
                    <OwnableInvalidOwner as alloy_sol_types::SolError>::SELECTOR
                }
                Self::OwnableUnauthorizedAccount(_) => {
                    <OwnableUnauthorizedAccount as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ReentrancyGuardReentrantCall(_) => {
                    <ReentrancyGuardReentrantCall as alloy_sol_types::SolError>::SELECTOR
                }
                Self::UnauthorizedCaller(_) => {
                    <UnauthorizedCaller as alloy_sol_types::SolError>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<UniswapV2ArbHookErrors>] = &[
                {
                    fn OwnableUnauthorizedAccount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UniswapV2ArbHookErrors> {
                        <OwnableUnauthorizedAccount as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(UniswapV2ArbHookErrors::OwnableUnauthorizedAccount)
                    }
                    OwnableUnauthorizedAccount
                },
                {
                    fn OwnableInvalidOwner(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UniswapV2ArbHookErrors> {
                        <OwnableInvalidOwner as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(UniswapV2ArbHookErrors::OwnableInvalidOwner)
                    }
                    OwnableInvalidOwner
                },
                {
                    fn ReentrancyGuardReentrantCall(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UniswapV2ArbHookErrors> {
                        <ReentrancyGuardReentrantCall as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(UniswapV2ArbHookErrors::ReentrancyGuardReentrantCall)
                    }
                    ReentrancyGuardReentrantCall
                },
                {
                    fn DEXNotSupported(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UniswapV2ArbHookErrors> {
                        <DEXNotSupported as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(UniswapV2ArbHookErrors::DEXNotSupported)
                    }
                    DEXNotSupported
                },
                {
                    fn InsufficientProfit(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UniswapV2ArbHookErrors> {
                        <InsufficientProfit as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(UniswapV2ArbHookErrors::InsufficientProfit)
                    }
                    InsufficientProfit
                },
                {
                    fn UnauthorizedCaller(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UniswapV2ArbHookErrors> {
                        <UnauthorizedCaller as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(UniswapV2ArbHookErrors::UnauthorizedCaller)
                    }
                    UnauthorizedCaller
                },
                {
                    fn InvalidEventData(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UniswapV2ArbHookErrors> {
                        <InvalidEventData as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(UniswapV2ArbHookErrors::InvalidEventData)
                    }
                    InvalidEventData
                },
                {
                    fn InvalidDEXConfig(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UniswapV2ArbHookErrors> {
                        <InvalidDEXConfig as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(UniswapV2ArbHookErrors::InvalidDEXConfig)
                    }
                    InvalidDEXConfig
                },
                {
                    fn ArbitrageFailed(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UniswapV2ArbHookErrors> {
                        <ArbitrageFailed as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(UniswapV2ArbHookErrors::ArbitrageFailed)
                    }
                    ArbitrageFailed
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data)
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw_validate(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_VALIDATE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<UniswapV2ArbHookErrors>] = &[
                {
                    fn OwnableUnauthorizedAccount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UniswapV2ArbHookErrors> {
                        <OwnableUnauthorizedAccount as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UniswapV2ArbHookErrors::OwnableUnauthorizedAccount)
                    }
                    OwnableUnauthorizedAccount
                },
                {
                    fn OwnableInvalidOwner(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UniswapV2ArbHookErrors> {
                        <OwnableInvalidOwner as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UniswapV2ArbHookErrors::OwnableInvalidOwner)
                    }
                    OwnableInvalidOwner
                },
                {
                    fn ReentrancyGuardReentrantCall(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UniswapV2ArbHookErrors> {
                        <ReentrancyGuardReentrantCall as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UniswapV2ArbHookErrors::ReentrancyGuardReentrantCall)
                    }
                    ReentrancyGuardReentrantCall
                },
                {
                    fn DEXNotSupported(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UniswapV2ArbHookErrors> {
                        <DEXNotSupported as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UniswapV2ArbHookErrors::DEXNotSupported)
                    }
                    DEXNotSupported
                },
                {
                    fn InsufficientProfit(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UniswapV2ArbHookErrors> {
                        <InsufficientProfit as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UniswapV2ArbHookErrors::InsufficientProfit)
                    }
                    InsufficientProfit
                },
                {
                    fn UnauthorizedCaller(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UniswapV2ArbHookErrors> {
                        <UnauthorizedCaller as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UniswapV2ArbHookErrors::UnauthorizedCaller)
                    }
                    UnauthorizedCaller
                },
                {
                    fn InvalidEventData(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UniswapV2ArbHookErrors> {
                        <InvalidEventData as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UniswapV2ArbHookErrors::InvalidEventData)
                    }
                    InvalidEventData
                },
                {
                    fn InvalidDEXConfig(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UniswapV2ArbHookErrors> {
                        <InvalidDEXConfig as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UniswapV2ArbHookErrors::InvalidDEXConfig)
                    }
                    InvalidDEXConfig
                },
                {
                    fn ArbitrageFailed(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UniswapV2ArbHookErrors> {
                        <ArbitrageFailed as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UniswapV2ArbHookErrors::ArbitrageFailed)
                    }
                    ArbitrageFailed
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_VALIDATE_SHIMS[idx](data)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::ArbitrageFailed(inner) => {
                    <ArbitrageFailed as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::DEXNotSupported(inner) => {
                    <DEXNotSupported as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InsufficientProfit(inner) => {
                    <InsufficientProfit as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidDEXConfig(inner) => {
                    <InvalidDEXConfig as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidEventData(inner) => {
                    <InvalidEventData as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::OwnableInvalidOwner(inner) => {
                    <OwnableInvalidOwner as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::OwnableUnauthorizedAccount(inner) => {
                    <OwnableUnauthorizedAccount as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ReentrancyGuardReentrantCall(inner) => {
                    <ReentrancyGuardReentrantCall as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::UnauthorizedCaller(inner) => {
                    <UnauthorizedCaller as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::ArbitrageFailed(inner) => {
                    <ArbitrageFailed as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::DEXNotSupported(inner) => {
                    <DEXNotSupported as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InsufficientProfit(inner) => {
                    <InsufficientProfit as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidDEXConfig(inner) => {
                    <InvalidDEXConfig as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidEventData(inner) => {
                    <InvalidEventData as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::OwnableInvalidOwner(inner) => {
                    <OwnableInvalidOwner as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::OwnableUnauthorizedAccount(inner) => {
                    <OwnableUnauthorizedAccount as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ReentrancyGuardReentrantCall(inner) => {
                    <ReentrancyGuardReentrantCall as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::UnauthorizedCaller(inner) => {
                    <UnauthorizedCaller as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`UniswapV2ArbHook`](self) events.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub enum UniswapV2ArbHookEvents {
        #[allow(missing_docs)]
        ArbitrageExecuted(ArbitrageExecuted),
        #[allow(missing_docs)]
        ArbitrageSkipped(ArbitrageSkipped),
        #[allow(missing_docs)]
        DEXAdded(DEXAdded),
        #[allow(missing_docs)]
        DEXRemoved(DEXRemoved),
        #[allow(missing_docs)]
        OwnershipTransferred(OwnershipTransferred),
    }
    #[automatically_derived]
    impl UniswapV2ArbHookEvents {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 32usize]] = &[
            [
                25u8, 33u8, 186u8, 102u8, 152u8, 21u8, 125u8, 73u8, 29u8, 65u8, 128u8,
                18u8, 134u8, 233u8, 225u8, 122u8, 238u8, 28u8, 37u8, 150u8, 81u8, 25u8,
                229u8, 84u8, 3u8, 186u8, 57u8, 107u8, 16u8, 75u8, 149u8, 219u8,
            ],
            [
                30u8, 183u8, 233u8, 110u8, 97u8, 109u8, 0u8, 48u8, 182u8, 80u8, 248u8,
                88u8, 216u8, 38u8, 60u8, 202u8, 242u8, 219u8, 8u8, 142u8, 41u8, 160u8,
                79u8, 1u8, 111u8, 142u8, 175u8, 154u8, 101u8, 47u8, 109u8, 44u8,
            ],
            [
                139u8, 224u8, 7u8, 156u8, 83u8, 22u8, 89u8, 20u8, 19u8, 68u8, 205u8,
                31u8, 208u8, 164u8, 242u8, 132u8, 25u8, 73u8, 127u8, 151u8, 34u8, 163u8,
                218u8, 175u8, 227u8, 180u8, 24u8, 111u8, 107u8, 100u8, 87u8, 224u8,
            ],
            [
                159u8, 222u8, 252u8, 49u8, 157u8, 91u8, 133u8, 127u8, 168u8, 236u8, 45u8,
                152u8, 91u8, 25u8, 224u8, 106u8, 168u8, 229u8, 180u8, 117u8, 23u8, 194u8,
                1u8, 25u8, 182u8, 64u8, 239u8, 126u8, 182u8, 66u8, 208u8, 13u8,
            ],
            [
                196u8, 5u8, 14u8, 130u8, 232u8, 80u8, 37u8, 63u8, 73u8, 41u8, 189u8,
                188u8, 209u8, 67u8, 238u8, 244u8, 135u8, 190u8, 47u8, 173u8, 100u8,
                115u8, 154u8, 79u8, 56u8, 89u8, 229u8, 20u8, 55u8, 69u8, 184u8, 50u8,
            ],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolEventInterface for UniswapV2ArbHookEvents {
        const NAME: &'static str = "UniswapV2ArbHookEvents";
        const COUNT: usize = 5usize;
        fn decode_raw_log(
            topics: &[alloy_sol_types::Word],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            match topics.first().copied() {
                Some(
                    <ArbitrageExecuted as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <ArbitrageExecuted as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::ArbitrageExecuted)
                }
                Some(<ArbitrageSkipped as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <ArbitrageSkipped as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::ArbitrageSkipped)
                }
                Some(<DEXAdded as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <DEXAdded as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::DEXAdded)
                }
                Some(<DEXRemoved as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <DEXRemoved as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::DEXRemoved)
                }
                Some(
                    <OwnershipTransferred as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <OwnershipTransferred as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::OwnershipTransferred)
                }
                _ => {
                    alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                        name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                        log: alloy_sol_types::private::Box::new(
                            alloy_sol_types::private::LogData::new_unchecked(
                                topics.to_vec(),
                                data.to_vec().into(),
                            ),
                        ),
                    })
                }
            }
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::private::IntoLogData for UniswapV2ArbHookEvents {
        fn to_log_data(&self) -> alloy_sol_types::private::LogData {
            match self {
                Self::ArbitrageExecuted(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::ArbitrageSkipped(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::DEXAdded(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::DEXRemoved(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::OwnershipTransferred(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
            }
        }
        fn into_log_data(self) -> alloy_sol_types::private::LogData {
            match self {
                Self::ArbitrageExecuted(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::ArbitrageSkipped(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::DEXAdded(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::DEXRemoved(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::OwnershipTransferred(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`UniswapV2ArbHook`](self) contract instance.

See the [wrapper's documentation](`UniswapV2ArbHookInstance`) for more details.*/
    #[inline]
    pub const fn new<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> UniswapV2ArbHookInstance<P, N> {
        UniswapV2ArbHookInstance::<P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<UniswapV2ArbHookInstance<P, N>>,
    > {
        UniswapV2ArbHookInstance::<P, N>::deploy(provider)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(provider: P) -> alloy_contract::RawCallBuilder<P, N> {
        UniswapV2ArbHookInstance::<P, N>::deploy_builder(provider)
    }
    /**A [`UniswapV2ArbHook`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`UniswapV2ArbHook`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct UniswapV2ArbHookInstance<P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network: ::core::marker::PhantomData<N>,
    }
    #[automatically_derived]
    impl<P, N> ::core::fmt::Debug for UniswapV2ArbHookInstance<P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("UniswapV2ArbHookInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > UniswapV2ArbHookInstance<P, N> {
        /**Creates a new wrapper around an on-chain [`UniswapV2ArbHook`](self) contract instance.

See the [wrapper's documentation](`UniswapV2ArbHookInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
        ) -> alloy_contract::Result<UniswapV2ArbHookInstance<P, N>> {
            let call_builder = Self::deploy_builder(provider);
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(provider: P) -> alloy_contract::RawCallBuilder<P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                ::core::clone::Clone::clone(&BYTECODE),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<P: ::core::clone::Clone, N> UniswapV2ArbHookInstance<&P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> UniswapV2ArbHookInstance<P, N> {
            UniswapV2ArbHookInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > UniswapV2ArbHookInstance<P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<&P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`_executeArbitrageLogic`] function.
        pub fn _executeArbitrageLogic(
            &self,
            pairAddress: alloy::sol_types::private::Address,
            amount0In: alloy::sol_types::private::primitives::aliases::U256,
            amount1In: alloy::sol_types::private::primitives::aliases::U256,
            amount0Out: alloy::sol_types::private::primitives::aliases::U256,
            amount1Out: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, _executeArbitrageLogicCall, N> {
            self.call_builder(
                &_executeArbitrageLogicCall {
                    pairAddress,
                    amount0In,
                    amount1In,
                    amount0Out,
                    amount1Out,
                },
            )
        }
        ///Creates a new call builder for the [`_getAmountOut`] function.
        pub fn _getAmountOut(
            &self,
            router: alloy::sol_types::private::Address,
            tokenIn: alloy::sol_types::private::Address,
            tokenOut: alloy::sol_types::private::Address,
            amountIn: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, _getAmountOutCall, N> {
            self.call_builder(
                &_getAmountOutCall {
                    router,
                    tokenIn,
                    tokenOut,
                    amountIn,
                },
            )
        }
        ///Creates a new call builder for the [`addDEX`] function.
        pub fn addDEX(
            &self,
            router: alloy::sol_types::private::Address,
            name: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<&P, addDEXCall, N> {
            self.call_builder(&addDEXCall { router, name })
        }
        ///Creates a new call builder for the [`authorizedTokens`] function.
        pub fn authorizedTokens(
            &self,
            _0: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, authorizedTokensCall, N> {
            self.call_builder(&authorizedTokensCall(_0))
        }
        ///Creates a new call builder for the [`dexConfigs`] function.
        pub fn dexConfigs(
            &self,
            _0: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, dexConfigsCall, N> {
            self.call_builder(&dexConfigsCall(_0))
        }
        ///Creates a new call builder for the [`gasCostBuffer`] function.
        pub fn gasCostBuffer(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, gasCostBufferCall, N> {
            self.call_builder(&gasCostBufferCall)
        }
        ///Creates a new call builder for the [`getDEXInfo`] function.
        pub fn getDEXInfo(
            &self,
            router: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, getDEXInfoCall, N> {
            self.call_builder(&getDEXInfoCall { router })
        }
        ///Creates a new call builder for the [`getSupportedDEXCount`] function.
        pub fn getSupportedDEXCount(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, getSupportedDEXCountCall, N> {
            self.call_builder(&getSupportedDEXCountCall)
        }
        ///Creates a new call builder for the [`maxTradeSize`] function.
        pub fn maxTradeSize(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, maxTradeSizeCall, N> {
            self.call_builder(&maxTradeSizeCall)
        }
        ///Creates a new call builder for the [`minProfitThreshold`] function.
        pub fn minProfitThreshold(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, minProfitThresholdCall, N> {
            self.call_builder(&minProfitThresholdCall)
        }
        ///Creates a new call builder for the [`onHook`] function.
        pub fn onHook(
            &self,
            contractAddr: alloy::sol_types::private::Address,
            topic0: alloy::sol_types::private::FixedBytes<32>,
            topic1: alloy::sol_types::private::FixedBytes<32>,
            topic2: alloy::sol_types::private::FixedBytes<32>,
            topic3: alloy::sol_types::private::FixedBytes<32>,
            eventData: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<&P, onHookCall, N> {
            self.call_builder(
                &onHookCall {
                    contractAddr,
                    topic0,
                    topic1,
                    topic2,
                    topic3,
                    eventData,
                },
            )
        }
        ///Creates a new call builder for the [`owner`] function.
        pub fn owner(&self) -> alloy_contract::SolCallBuilder<&P, ownerCall, N> {
            self.call_builder(&ownerCall)
        }
        ///Creates a new call builder for the [`pairRegistry`] function.
        pub fn pairRegistry(
            &self,
            _0: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, pairRegistryCall, N> {
            self.call_builder(&pairRegistryCall(_0))
        }
        ///Creates a new call builder for the [`pairToDEX`] function.
        pub fn pairToDEX(
            &self,
            _0: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, pairToDEXCall, N> {
            self.call_builder(&pairToDEXCall(_0))
        }
        ///Creates a new call builder for the [`registerPair`] function.
        pub fn registerPair(
            &self,
            tokenA: alloy::sol_types::private::Address,
            tokenB: alloy::sol_types::private::Address,
            pairAddress: alloy::sol_types::private::Address,
            dexRouter: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, registerPairCall, N> {
            self.call_builder(
                &registerPairCall {
                    tokenA,
                    tokenB,
                    pairAddress,
                    dexRouter,
                },
            )
        }
        ///Creates a new call builder for the [`removeDEX`] function.
        pub fn removeDEX(
            &self,
            router: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, removeDEXCall, N> {
            self.call_builder(&removeDEXCall { router })
        }
        ///Creates a new call builder for the [`renounceOwnership`] function.
        pub fn renounceOwnership(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, renounceOwnershipCall, N> {
            self.call_builder(&renounceOwnershipCall)
        }
        ///Creates a new call builder for the [`sequencer`] function.
        pub fn sequencer(&self) -> alloy_contract::SolCallBuilder<&P, sequencerCall, N> {
            self.call_builder(&sequencerCall)
        }
        ///Creates a new call builder for the [`setAuthorizedToken`] function.
        pub fn setAuthorizedToken(
            &self,
            token: alloy::sol_types::private::Address,
            authorized: bool,
        ) -> alloy_contract::SolCallBuilder<&P, setAuthorizedTokenCall, N> {
            self.call_builder(
                &setAuthorizedTokenCall {
                    token,
                    authorized,
                },
            )
        }
        ///Creates a new call builder for the [`setGasCostBuffer`] function.
        pub fn setGasCostBuffer(
            &self,
            buffer: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, setGasCostBufferCall, N> {
            self.call_builder(&setGasCostBufferCall { buffer })
        }
        ///Creates a new call builder for the [`setMaxTradeSize`] function.
        pub fn setMaxTradeSize(
            &self,
            size: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, setMaxTradeSizeCall, N> {
            self.call_builder(&setMaxTradeSizeCall { size })
        }
        ///Creates a new call builder for the [`setMinProfitThreshold`] function.
        pub fn setMinProfitThreshold(
            &self,
            threshold: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, setMinProfitThresholdCall, N> {
            self.call_builder(
                &setMinProfitThresholdCall {
                    threshold,
                },
            )
        }
        ///Creates a new call builder for the [`setSequencer`] function.
        pub fn setSequencer(
            &self,
            _sequencer: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, setSequencerCall, N> {
            self.call_builder(&setSequencerCall { _sequencer })
        }
        ///Creates a new call builder for the [`supportedDEXes`] function.
        pub fn supportedDEXes(
            &self,
            _0: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, supportedDEXesCall, N> {
            self.call_builder(&supportedDEXesCall(_0))
        }
        ///Creates a new call builder for the [`transferOwnership`] function.
        pub fn transferOwnership(
            &self,
            newOwner: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, transferOwnershipCall, N> {
            self.call_builder(&transferOwnershipCall { newOwner })
        }
        ///Creates a new call builder for the [`withdrawETH`] function.
        pub fn withdrawETH(
            &self,
            amount: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, withdrawETHCall, N> {
            self.call_builder(&withdrawETHCall { amount })
        }
        ///Creates a new call builder for the [`withdrawToken`] function.
        pub fn withdrawToken(
            &self,
            token: alloy::sol_types::private::Address,
            amount: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, withdrawTokenCall, N> {
            self.call_builder(&withdrawTokenCall { token, amount })
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > UniswapV2ArbHookInstance<P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<&P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
        ///Creates a new event filter for the [`ArbitrageExecuted`] event.
        pub fn ArbitrageExecuted_filter(
            &self,
        ) -> alloy_contract::Event<&P, ArbitrageExecuted, N> {
            self.event_filter::<ArbitrageExecuted>()
        }
        ///Creates a new event filter for the [`ArbitrageSkipped`] event.
        pub fn ArbitrageSkipped_filter(
            &self,
        ) -> alloy_contract::Event<&P, ArbitrageSkipped, N> {
            self.event_filter::<ArbitrageSkipped>()
        }
        ///Creates a new event filter for the [`DEXAdded`] event.
        pub fn DEXAdded_filter(&self) -> alloy_contract::Event<&P, DEXAdded, N> {
            self.event_filter::<DEXAdded>()
        }
        ///Creates a new event filter for the [`DEXRemoved`] event.
        pub fn DEXRemoved_filter(&self) -> alloy_contract::Event<&P, DEXRemoved, N> {
            self.event_filter::<DEXRemoved>()
        }
        ///Creates a new event filter for the [`OwnershipTransferred`] event.
        pub fn OwnershipTransferred_filter(
            &self,
        ) -> alloy_contract::Event<&P, OwnershipTransferred, N> {
            self.event_filter::<OwnershipTransferred>()
        }
    }
}
